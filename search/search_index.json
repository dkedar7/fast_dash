{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Open source, Python-based tool to build prototypes lightning fast \u26a1 </p> <p> </p> <ul> <li>Documentation: https://docs.fastdash.app</li> <li>Source code: github.com/dkedar7/fast_dash</li> <li>Installation: <code>pip install fast-dash</code></li> </ul> <p>Fast Dash is a Python module that makes the development of web applications fast and easy. It can build web interfaces for Machine Learning models or to showcase any proof of concept without the hassle of developing UI from scratch.</p> <p></p>"},{"location":"#examples","title":"Examples","text":"<p>With Fast Dash's decorator <code>@fastdash</code>, it's a breeze to deploy any Python function as a web app. Here's how to use it to write your first Fast Dash app: <pre><code>from fast_dash import fastdash\n\n@fastdash\ndef text_to_text_function(input_text):\n    return input_text\n\n# * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)\n</code></pre></p> <p>And just like that (\ud83e\ude84), we have a completely functional interactive app!</p> <p>Output: </p> <p>Fast Dash can read all the function details, like its name, input and output types, docstring, and uses this information to infer which components to use.</p> <p>For example, here's how to deploy an app that takes a string and an integer as inputs and returns some text.</p> <pre><code>from fast_dash import fastdash\n\n@fastdash\ndef display_selected_text_and_number(text: str, number: int) -&gt; str:\n    \"Simply display the selected text and number\"\n\n    processed_text = f'Selected text is {text} and the number is {number}.'\n\n    return processed_text\n\n# * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)\n</code></pre> <p>Output: </p> <p>And with just a few more lines, we can add a title icon, subheader and other social branding details.</p> <p>Output components can be arranged using a mosaic layout (ASCII art), inspired from Matplotlib's <code>subplot_mosaic</code> feature.</p> <p><pre><code>from fast_dash import fastdash, UploadImage, Graph\nimport matplotlib.pyplot as plt\n\nmosaic = \"\"\"\nAB\nAC\n\"\"\"\n\n@fastdash(mosaic=mosaic, theme=\"BOOTSTRAP\")\ndef multiple_output_components(start_date: datetime.date, # Adds a date component\n                            upload_image: UploadImage, # Adds an upload component\n                            fips: str = [List of FIPs]) # Adds a single select dropdown\n                            -&gt; (Graph, plt.Figure, plt.Figure): \n                            # Output components are a Plotly graph, and two figure components\n\n    \"Fast Dash allows using mosaic arrays to arrange output components\"\n\n    choropleth_map = ...\n    histogram = ...\n    radar_chart = ...\n\n    return chloropleth_map, histogram, radar_chart\n\n# * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)\n</code></pre> </p>"},{"location":"#about","title":"About","text":"<p>Read different ways to build Fast Dash apps and additional details by navigating to the project documentation.</p>"},{"location":"#key-features","title":"Key features","text":"<p>Duild and deploy a web app by adding a decorator only. - Components are inferred from function type hints. Allows using Dash components as type hints. - Use multiple input and output components simultaneously. - Build fast, share and iterate.</p>"},{"location":"#community","title":"Community","text":"<p>Fast Dash is built using Plotly Dash and it's completely open-source.</p>"},{"location":"#citation","title":"Citation","text":"<p>Please cite Fast Dash if you use it in your work. <pre><code>@software{Kedar_Dabhadkar_Fast_Dash,\nauthor = {Kedar Dabhadkar},\ntitle = {{Fast Dash}}\n}\n</code></pre></p>"},{"location":"api/","title":"Modules","text":"<p>Top-level package for Fast Dash.</p>"},{"location":"api/#fast_dash.FastDash","title":"<code>FastDash</code>","text":"<p>Fast Dash app object containing automatically generated UI components and callbacks.</p> <p>This is the primary Fast Dash data structure. Can be thought of as a wrapper around a flask WSGI application. It has in-built support for automated UI generation and sets all parameters required for Fast Dash app deployment.</p> Source code in <code>fast_dash/fast_dash.py</code> <pre><code>class FastDash:\n\"\"\"\n    Fast Dash app object containing automatically generated UI components and callbacks.\n\n    This is the primary Fast Dash data structure. Can be thought of as a wrapper around\n    a flask WSGI application. It has in-built support for automated UI generation and\n    sets all parameters required for Fast Dash app deployment.\n    \"\"\"\n\n    def __init__(\n        self,\n        callback_fn,\n        layout=\"sidebar\",\n        mosaic=None,\n        inputs=None,\n        outputs=None,\n        output_labels=\"infer\",\n        title=None,\n        title_image_path=None,\n        subheader=None,\n        github_url=None,\n        linkedin_url=None,\n        twitter_url=None,\n        navbar=True,\n        footer=True,\n        about=True,\n        theme=None,\n        update_live=False,\n        port=8080,\n        mode=None,\n        minimal=False,\n        disable_logs=False,\n        scale_height=1,\n        run_kwargs=dict(),\n        **kwargs\n    ):\n\"\"\"\n        Args:\n            callback_fn (func): Python function that Fast Dash deploys. \\\n                This function guides the behavior of and interaction between input and output components.\n\n            layout (str, optional): App layout style. Currently supports 'base' and 'sidebar'. Defaults to sidebar.\n\n            mosaic (str): Mosaic array layout, if sidebar layout is selected.\n\n            inputs (Fast component, list of Fast components, optional): Components to represent inputs of the callback function.\\\n                Defaults to None. If `None`, Fast Dash attempts to infer the best components from callback function's type \\\n                hints and default values. In the absence of type hints, default components are all `Text`.\n\n            outputs (Fast component, list of Fast components, optional): Components to represent outputs of the callback function.\\\n                Defaults to None. If `None`, Fast Dash attempts to infer the best components from callback function's type hints.\\\n                In the absence of type hints, default components are all `Text`.\n\n            output_labels(list of string labels or \"infer\" or None, optional): Labels given to the output components. If None, inputs are\\\n                set labeled integers starting at 1 (Output 1, Output 2, and so on). If \"infer\", labels are inferred from the function\\\n                signature. Defaults to infer.\n\n            title (str, optional): Title given to the app. If `None`, function name (assumed to be in snake case)\\\n                is converted to title case. Defaults to None.\n\n            title_image_path (str, optional): Path (local or URL) of the app title image. Defaults to None.\n\n            subheader (str, optional): Subheader of the app, displayed below the title image and title\\\n                If `None`, Fast Dash tries to use the callback function's docstring instead. Defaults to None.\n\n\n            github_url (str, optional): GitHub URL for branding. Displays a GitHub logo in the navbar, which takes users to the\\\n                specified URL. Defaults to None.\n\n            linkedin_url (str, optional): LinkedIn URL for branding Displays a LinkedIn logo in the navbar, which takes users to the\\\n                specified URL. Defaults to None.\n\n            twitter_url (str, optional): Twitter URL for branding. Displays a Twitter logo in the navbar, which takes users to the\\\n                specified URL. Defaults to None.\n\n            navbar (bool, optional): Display navbar. Defaults to True.\n\n            footer (bool, optional): Display footer. Defaults to True.\n\n            about (Union[str, bool], optional): App description to display on clicking the `About` button. If True, content is inferred from\\\n                the docstring of the callback function. If string, content is used directly as markdown. \\\n                `About` is hidden if False or None. Defaults to True.\n\n            theme (str, optional): Apply theme to the app.All available themes can be found at https://bootswatch.com/. Defaults to JOURNAL. \n\n            update_live (bool, optional): Enable hot reloading. If the number of inputs is 0, this is set to True automatically. Defaults to False.\n\n            port (int, optional): Port to which the app should be deployed. Defaults to 8080.\n\n            mode (str, optional): Mode in which to launch the app. Acceptable options are `None`, `jupyterlab`, `inline`, 'external`.\\\n                Defaults to None.\n\n            minimal (bool, optional): Display minimal version by hiding navbar, title, title image, subheader and footer. Defaults to False.\n\n            disable_logs (bool, optional): Hide app logs. Sets logger level to `ERROR`. Defaults to False.\n\n            scale_height (float, optional): Height of the app container is enlarged as a multiple of this. Defaults to 1.\n\n            run_kwargs (dict, optional): All values from this variable are passed to Dash's `.run` method.\n        \"\"\"\n\n        self.callback_fn = callback_fn\n        self.layout_pattern = layout\n        self.mosaic = mosaic\n        self.output_labels = output_labels\n\n        if output_labels == \"infer\":\n            self.output_labels = _infer_variable_names(callback_fn)\n\n        self.inputs = (\n            _infer_input_components(callback_fn)\n            if inputs is None\n            else inputs\n            if isinstance(inputs, list)\n            else [inputs]\n        )\n        self.outputs = _infer_output_components(\n            callback_fn, outputs, self.output_labels\n        )\n        self.update_live = (\n            True\n            if (isinstance(self.inputs, list) and len(self.inputs) == 0)\n            else update_live\n        )\n        self.mode = mode\n        self.disable_logs = disable_logs\n        self.scale_height = scale_height\n        self.port = port\n        self.run_kwargs = run_kwargs\n        self.run_kwargs.update(dict(port=port))\n        self.kwargs = kwargs\n\n        if self.disable_logs is True:\n            log = logging.getLogger(\"werkzeug\")\n            log.setLevel(logging.ERROR)\n\n        else:\n            log = logging.getLogger(\"werkzeug\")\n            log.setLevel(logging.DEBUG)\n\n        if title is None:\n            title = re.sub(\"[^0-9a-zA-Z]+\", \" \", callback_fn.__name__).title()\n\n        self.title = title\n        self.title_image_path = title_image_path\n        self.subtitle = (\n            subheader\n            if subheader is not None\n            else _parse_docstring_as_markdown(callback_fn, title=self.title, get_short=True)\n        )\n        self.github_url = github_url\n        self.linkedin_url = linkedin_url\n        self.twitter_url = twitter_url\n        self.navbar = navbar\n        self.footer = footer\n        self.about = about\n        self.theme = theme or \"JOURNAL\"\n        self.minimal = minimal\n\n        # Extract input tags\n        self.input_tags = [inp.tag for inp in self.inputs]\n        self.output_tags = [inp.tag for inp in self.outputs]\n\n        # Assign IDs to components\n        self.inputs_with_ids = _assign_ids_to_inputs(self.inputs, self.callback_fn)\n        self.outputs_with_ids = _assign_ids_to_outputs(self.outputs)\n        self.ack_mask = [\n            False if (not hasattr(input_, \"ack\") or (input_.ack is None)) else True\n            for input_ in self.inputs_with_ids\n        ]\n\n        # Default state of outputs\n        self.output_state_default = [\n            output_.placeholder if hasattr(output_, \"placeholder\") else None\n            for output_ in self.outputs_with_ids\n        ]\n\n        self.output_state_blank = [None for output_ in self.outputs_with_ids]\n        self.latest_output_state = self.output_state_blank\n\n        # Define Flask server\n        server = flask.Flask(__name__)\n        external_stylesheets = [\n            theme_mapper(self.theme),\n            \"https://use.fontawesome.com/releases/v5.9.0/css/all.css\",\n        ]\n\n        source = dash.Dash\n        # if self.mode is not None:\n        #     try:\n        #         from jupyter_dash import JupyterDash\n\n        #         source = JupyterDash\n\n        #     except ImportError as e:\n        #         self.mode = None\n        #         warnings.warn(str(e))\n        #         warnings.warn(\"Ignoring mode argument\")\n\n        self.app = source(\n            __name__,\n            external_stylesheets=external_stylesheets,\n            server=server,\n            **self.kwargs\n        )\n        # Define app title\n        self.app.title = self.title or \"\"\n\n        # Intialize layout\n        self.set_layout()\n\n        # Register callbacks\n        self.register_callback_fn()\n\n        # Keep track of the number of clicks\n        self.submit_clicks = 0\n        self.reset_clicks = 0\n        self.app_initialized = False\n\n        # Allow easier access to Dash server\n        self.server = self.app.server\n\n    def run(self):\n        self.app.run(\n            **self.run_kwargs\n        ) if self.mode is None else self.app.run_server(\n            jupyter_mode=self.mode, **self.run_kwargs\n        )\n\n    def run_server(self):\n        self.app.run_server(\n            **self.run_kwargs\n        ) if self.mode is None else self.app.run_server(\n            jupyter_mode=self.mode, **self.run_kwargs\n        )\n\n    def set_layout(self):\n        if self.inputs is not None:\n            input_groups = _make_input_groups(self.inputs_with_ids, self.update_live)\n\n        if self.outputs is not None:\n            output_groups = _make_output_groups(self.outputs_with_ids, self.update_live)\n\n        layout_args = {\n            \"mosaic\": self.mosaic,\n            \"inputs\": input_groups,\n            \"outputs\": output_groups,\n            \"title\": self.title,\n            \"title_image_path\": self.title_image_path,\n            \"subtitle\": self.subtitle,\n            \"github_url\": self.github_url,\n            \"linkedin_url\": self.linkedin_url,\n            \"twitter_url\": self.twitter_url,\n            \"navbar\": self.navbar,\n            \"footer\": self.footer,\n            \"about\": self.about,\n            \"minimal\": self.minimal,\n            \"scale_height\": self.scale_height,\n            \"app\": self,\n        }\n\n        if self.layout_pattern == \"sidebar\":\n            app_layout = SidebarLayout(**layout_args)\n\n        else:\n            app_layout = BaseLayout(**layout_args)\n\n        self.layout_object = app_layout\n        self.app.layout = app_layout.generate_layout()\n\n    def register_callback_fn(self):\n        @self.app.callback(\n            [\n                Output(\n                    component_id=output_.id,\n                    component_property=output_.component_property,\n                )\n                for output_ in self.outputs_with_ids\n            ]\n            + [Output(\"error-notify-div\", \"children\")],\n            [\n                Input(\n                    component_id=input_.id, component_property=input_.component_property\n                )\n                for input_ in self.inputs_with_ids\n            ]\n            + [\n                Input(component_id=\"reset_inputs\", component_property=\"n_clicks\"),\n                Input(component_id=\"submit_inputs\", component_property=\"n_clicks\"),\n            ],\n            prevent_initial_callback=True,\n        )\n        def process_input(*args):\n            if ctx.triggered_id not in [\"submit_inputs\", \"reset_inputs\"]:\n                raise PreventUpdate\n\n            default_notification = None\n\n            try:\n                inputs = _transform_inputs(args[:-2], self.input_tags)\n\n                if ctx.triggered_id == \"submit_inputs\" or (\n                    self.update_live is True and None not in args\n                ):\n                    self.app_initialized = True\n\n                    output_state = self.callback_fn(*inputs)\n\n                    if isinstance(output_state, tuple):\n                        self.output_state = list(output_state)\n\n                    else:\n                        self.output_state = [output_state]\n\n                    # Transform outputs to fit in the desired components\n                    self.output_state = _transform_outputs(\n                        self.output_state, self.output_tags\n                    )\n\n                    # Log the latest output state\n                    self.latest_output_state = self.output_state\n\n                    return self.output_state + [default_notification]\n\n                elif ctx.triggered_id == \"reset_inputs\":\n                    self.output_state = self.output_state_default\n                    return self.output_state + [default_notification]\n\n                elif self.app_initialized:\n                    return self.output_state + [default_notification]\n\n                else:\n                    return self.output_state_default + [default_notification]\n\n            except Exception as e:\n                traceback.print_exc()\n                notification = _get_error_notification_component(str(e))\n\n                return self.output_state_default + [notification]\n\n        @self.app.callback(\n            [\n                Output(\n                    component_id=input_.ack.id,\n                    component_property=input_.ack.component_property,\n                )\n                for input_ in self.inputs_with_ids\n            ],\n            [\n                Input(\n                    component_id=input_.id, component_property=input_.component_property\n                )\n                for input_ in self.inputs_with_ids\n            ],\n        )\n        def process_ack_outputs(*args):\n            ack_components = [\n                ack if mask is True else None\n                for mask, ack in zip(self.ack_mask, list(args))\n            ]\n            return ack_components\n\n        # Set layout callbacks\n        if not self.minimal:\n            self.layout_object.callbacks(self)\n</code></pre>"},{"location":"api/#fast_dash.fast_dash.FastDash.__init__","title":"<code>__init__(callback_fn, layout='sidebar', mosaic=None, inputs=None, outputs=None, output_labels='infer', title=None, title_image_path=None, subheader=None, github_url=None, linkedin_url=None, twitter_url=None, navbar=True, footer=True, about=True, theme=None, update_live=False, port=8080, mode=None, minimal=False, disable_logs=False, scale_height=1, run_kwargs=dict(), kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>callback_fn</code> <code>func</code> <p>Python function that Fast Dash deploys.                 This function guides the behavior of and interaction between input and output components.</p> required <code>layout</code> <code>str</code> <p>App layout style. Currently supports 'base' and 'sidebar'. Defaults to sidebar.</p> <code>'sidebar'</code> <code>mosaic</code> <code>str</code> <p>Mosaic array layout, if sidebar layout is selected.</p> <code>None</code> <code>inputs</code> <code>Fast component, list of Fast components</code> <p>Components to represent inputs of the callback function.                Defaults to None. If <code>None</code>, Fast Dash attempts to infer the best components from callback function's type                 hints and default values. In the absence of type hints, default components are all <code>Text</code>.</p> <code>None</code> <code>outputs</code> <code>Fast component, list of Fast components</code> <p>Components to represent outputs of the callback function.                Defaults to None. If <code>None</code>, Fast Dash attempts to infer the best components from callback function's type hints.                In the absence of type hints, default components are all <code>Text</code>.</p> <code>None</code> <code>output_labels(list</code> <code>of string labels or \"infer\" or None</code> <p>Labels given to the output components. If None, inputs are                set labeled integers starting at 1 (Output 1, Output 2, and so on). If \"infer\", labels are inferred from the function                signature. Defaults to infer.</p> required <code>title</code> <code>str</code> <p>Title given to the app. If <code>None</code>, function name (assumed to be in snake case)                is converted to title case. Defaults to None.</p> <code>None</code> <code>title_image_path</code> <code>str</code> <p>Path (local or URL) of the app title image. Defaults to None.</p> <code>None</code> <code>subheader</code> <code>str</code> <p>Subheader of the app, displayed below the title image and title                If <code>None</code>, Fast Dash tries to use the callback function's docstring instead. Defaults to None.</p> <code>None</code> <code>github_url</code> <code>str</code> <p>GitHub URL for branding. Displays a GitHub logo in the navbar, which takes users to the                specified URL. Defaults to None.</p> <code>None</code> <code>linkedin_url</code> <code>str</code> <p>LinkedIn URL for branding Displays a LinkedIn logo in the navbar, which takes users to the                specified URL. Defaults to None.</p> <code>None</code> <code>twitter_url</code> <code>str</code> <p>Twitter URL for branding. Displays a Twitter logo in the navbar, which takes users to the                specified URL. Defaults to None.</p> <code>None</code> <code>navbar</code> <code>bool</code> <p>Display navbar. Defaults to True.</p> <code>True</code> <code>footer</code> <code>bool</code> <p>Display footer. Defaults to True.</p> <code>True</code> <code>about</code> <code>Union[str, bool]</code> <p>App description to display on clicking the <code>About</code> button. If True, content is inferred from                the docstring of the callback function. If string, content is used directly as markdown.                 <code>About</code> is hidden if False or None. Defaults to True.</p> <code>True</code> <code>theme</code> <code>str</code> <p>Apply theme to the app.All available themes can be found at https://bootswatch.com/. Defaults to JOURNAL. </p> <code>None</code> <code>update_live</code> <code>bool</code> <p>Enable hot reloading. If the number of inputs is 0, this is set to True automatically. Defaults to False.</p> <code>False</code> <code>port</code> <code>int</code> <p>Port to which the app should be deployed. Defaults to 8080.</p> <code>8080</code> <code>mode</code> <code>str</code> <p>Mode in which to launch the app. Acceptable options are <code>None</code>, <code>jupyterlab</code>, <code>inline</code>, 'external`.                Defaults to None.</p> <code>None</code> <code>minimal</code> <code>bool</code> <p>Display minimal version by hiding navbar, title, title image, subheader and footer. Defaults to False.</p> <code>False</code> <code>disable_logs</code> <code>bool</code> <p>Hide app logs. Sets logger level to <code>ERROR</code>. Defaults to False.</p> <code>False</code> <code>scale_height</code> <code>float</code> <p>Height of the app container is enlarged as a multiple of this. Defaults to 1.</p> <code>1</code> <code>run_kwargs</code> <code>dict</code> <p>All values from this variable are passed to Dash's <code>.run</code> method.</p> <code>dict()</code> Source code in <code>fast_dash/fast_dash.py</code> <pre><code>def __init__(\n    self,\n    callback_fn,\n    layout=\"sidebar\",\n    mosaic=None,\n    inputs=None,\n    outputs=None,\n    output_labels=\"infer\",\n    title=None,\n    title_image_path=None,\n    subheader=None,\n    github_url=None,\n    linkedin_url=None,\n    twitter_url=None,\n    navbar=True,\n    footer=True,\n    about=True,\n    theme=None,\n    update_live=False,\n    port=8080,\n    mode=None,\n    minimal=False,\n    disable_logs=False,\n    scale_height=1,\n    run_kwargs=dict(),\n    **kwargs\n):\n\"\"\"\n    Args:\n        callback_fn (func): Python function that Fast Dash deploys. \\\n            This function guides the behavior of and interaction between input and output components.\n\n        layout (str, optional): App layout style. Currently supports 'base' and 'sidebar'. Defaults to sidebar.\n\n        mosaic (str): Mosaic array layout, if sidebar layout is selected.\n\n        inputs (Fast component, list of Fast components, optional): Components to represent inputs of the callback function.\\\n            Defaults to None. If `None`, Fast Dash attempts to infer the best components from callback function's type \\\n            hints and default values. In the absence of type hints, default components are all `Text`.\n\n        outputs (Fast component, list of Fast components, optional): Components to represent outputs of the callback function.\\\n            Defaults to None. If `None`, Fast Dash attempts to infer the best components from callback function's type hints.\\\n            In the absence of type hints, default components are all `Text`.\n\n        output_labels(list of string labels or \"infer\" or None, optional): Labels given to the output components. If None, inputs are\\\n            set labeled integers starting at 1 (Output 1, Output 2, and so on). If \"infer\", labels are inferred from the function\\\n            signature. Defaults to infer.\n\n        title (str, optional): Title given to the app. If `None`, function name (assumed to be in snake case)\\\n            is converted to title case. Defaults to None.\n\n        title_image_path (str, optional): Path (local or URL) of the app title image. Defaults to None.\n\n        subheader (str, optional): Subheader of the app, displayed below the title image and title\\\n            If `None`, Fast Dash tries to use the callback function's docstring instead. Defaults to None.\n\n\n        github_url (str, optional): GitHub URL for branding. Displays a GitHub logo in the navbar, which takes users to the\\\n            specified URL. Defaults to None.\n\n        linkedin_url (str, optional): LinkedIn URL for branding Displays a LinkedIn logo in the navbar, which takes users to the\\\n            specified URL. Defaults to None.\n\n        twitter_url (str, optional): Twitter URL for branding. Displays a Twitter logo in the navbar, which takes users to the\\\n            specified URL. Defaults to None.\n\n        navbar (bool, optional): Display navbar. Defaults to True.\n\n        footer (bool, optional): Display footer. Defaults to True.\n\n        about (Union[str, bool], optional): App description to display on clicking the `About` button. If True, content is inferred from\\\n            the docstring of the callback function. If string, content is used directly as markdown. \\\n            `About` is hidden if False or None. Defaults to True.\n\n        theme (str, optional): Apply theme to the app.All available themes can be found at https://bootswatch.com/. Defaults to JOURNAL. \n\n        update_live (bool, optional): Enable hot reloading. If the number of inputs is 0, this is set to True automatically. Defaults to False.\n\n        port (int, optional): Port to which the app should be deployed. Defaults to 8080.\n\n        mode (str, optional): Mode in which to launch the app. Acceptable options are `None`, `jupyterlab`, `inline`, 'external`.\\\n            Defaults to None.\n\n        minimal (bool, optional): Display minimal version by hiding navbar, title, title image, subheader and footer. Defaults to False.\n\n        disable_logs (bool, optional): Hide app logs. Sets logger level to `ERROR`. Defaults to False.\n\n        scale_height (float, optional): Height of the app container is enlarged as a multiple of this. Defaults to 1.\n\n        run_kwargs (dict, optional): All values from this variable are passed to Dash's `.run` method.\n    \"\"\"\n\n    self.callback_fn = callback_fn\n    self.layout_pattern = layout\n    self.mosaic = mosaic\n    self.output_labels = output_labels\n\n    if output_labels == \"infer\":\n        self.output_labels = _infer_variable_names(callback_fn)\n\n    self.inputs = (\n        _infer_input_components(callback_fn)\n        if inputs is None\n        else inputs\n        if isinstance(inputs, list)\n        else [inputs]\n    )\n    self.outputs = _infer_output_components(\n        callback_fn, outputs, self.output_labels\n    )\n    self.update_live = (\n        True\n        if (isinstance(self.inputs, list) and len(self.inputs) == 0)\n        else update_live\n    )\n    self.mode = mode\n    self.disable_logs = disable_logs\n    self.scale_height = scale_height\n    self.port = port\n    self.run_kwargs = run_kwargs\n    self.run_kwargs.update(dict(port=port))\n    self.kwargs = kwargs\n\n    if self.disable_logs is True:\n        log = logging.getLogger(\"werkzeug\")\n        log.setLevel(logging.ERROR)\n\n    else:\n        log = logging.getLogger(\"werkzeug\")\n        log.setLevel(logging.DEBUG)\n\n    if title is None:\n        title = re.sub(\"[^0-9a-zA-Z]+\", \" \", callback_fn.__name__).title()\n\n    self.title = title\n    self.title_image_path = title_image_path\n    self.subtitle = (\n        subheader\n        if subheader is not None\n        else _parse_docstring_as_markdown(callback_fn, title=self.title, get_short=True)\n    )\n    self.github_url = github_url\n    self.linkedin_url = linkedin_url\n    self.twitter_url = twitter_url\n    self.navbar = navbar\n    self.footer = footer\n    self.about = about\n    self.theme = theme or \"JOURNAL\"\n    self.minimal = minimal\n\n    # Extract input tags\n    self.input_tags = [inp.tag for inp in self.inputs]\n    self.output_tags = [inp.tag for inp in self.outputs]\n\n    # Assign IDs to components\n    self.inputs_with_ids = _assign_ids_to_inputs(self.inputs, self.callback_fn)\n    self.outputs_with_ids = _assign_ids_to_outputs(self.outputs)\n    self.ack_mask = [\n        False if (not hasattr(input_, \"ack\") or (input_.ack is None)) else True\n        for input_ in self.inputs_with_ids\n    ]\n\n    # Default state of outputs\n    self.output_state_default = [\n        output_.placeholder if hasattr(output_, \"placeholder\") else None\n        for output_ in self.outputs_with_ids\n    ]\n\n    self.output_state_blank = [None for output_ in self.outputs_with_ids]\n    self.latest_output_state = self.output_state_blank\n\n    # Define Flask server\n    server = flask.Flask(__name__)\n    external_stylesheets = [\n        theme_mapper(self.theme),\n        \"https://use.fontawesome.com/releases/v5.9.0/css/all.css\",\n    ]\n\n    source = dash.Dash\n    # if self.mode is not None:\n    #     try:\n    #         from jupyter_dash import JupyterDash\n\n    #         source = JupyterDash\n\n    #     except ImportError as e:\n    #         self.mode = None\n    #         warnings.warn(str(e))\n    #         warnings.warn(\"Ignoring mode argument\")\n\n    self.app = source(\n        __name__,\n        external_stylesheets=external_stylesheets,\n        server=server,\n        **self.kwargs\n    )\n    # Define app title\n    self.app.title = self.title or \"\"\n\n    # Intialize layout\n    self.set_layout()\n\n    # Register callbacks\n    self.register_callback_fn()\n\n    # Keep track of the number of clicks\n    self.submit_clicks = 0\n    self.reset_clicks = 0\n    self.app_initialized = False\n\n    # Allow easier access to Dash server\n    self.server = self.app.server\n</code></pre>"},{"location":"api/#fast_dash.Fastify","title":"<code>Fastify(component, component_property, ack=None, placeholder=None, label_=None, tag=None, args, kwargs)</code>","text":"<p>Modify a Dash component into a FastComponent.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Dash component</code> <p>Dash component that needs to be modified</p> required <code>component_property</code> <code>str</code> <p>Component property that's assigned the input or output values</p> required <code>ack</code> <code>Dash component</code> <p>Dash component that's displayed as an acknowledgement of the original component</p> <code>None</code> <code>placeholder</code> <code>str</code> <p>Placeholder value of the component.</p> <code>None</code> <code>label_</code> <code>str</code> <p>Component title.</p> <code>None</code> <code>tag</code> <code>str</code> <p>Optional tag applied to the component.</p> <code>None</code> <p>Returns:</p> Type Description <p>Fast component: Dash component modified to make it compatible with Fast Dash.</p> Source code in <code>fast_dash/utils.py</code> <pre><code>def Fastify(component, component_property, ack=None, placeholder=None, label_=None,tag=None, *args, **kwargs):\n\"\"\"\n    Modify a Dash component into a FastComponent.\n\n    Args:\n        component (Dash component): Dash component that needs to be modified\n        component_property (str): Component property that's assigned the input or output values\n        ack (Dash component, optional): Dash component that's displayed as an acknowledgement of the original component\n        placeholder (str, optional): Placeholder value of the component.\n        label_ (str, optional): Component title.\n        tag (str, optional): Optional tag applied to the component.\n\n    Returns:\n        Fast component: Dash component modified to make it compatible with Fast Dash.\n    \"\"\"\n\n    class FastComponent(type(component)):\n        def __init__(self, component, component_property, ack=ack, placeholder=placeholder, label_=label_, tag=tag, *args, **kwargs):\n\n            self.component_property = component_property\n            self.ack = ack\n            self.label_ = label_\n            self.placeholder = placeholder\n            self.tag = tag\n\n            # Copy normal attributes\n            for attr_name, attr_value in vars(component).items():\n                setattr(self, attr_name, attr_value)\n\n            # Copy the __doc__ attribute\n            self.__doc__ = component.__doc__\n\n            for key, value in kwargs.items():\n                setattr(self, key, value)\n\n        def __call__(self, **kwargs):            \n            self_copy = copy.deepcopy(self)\n            for key, value in kwargs.items():\n                setattr(self_copy, key, value)\n\n            return self_copy\n\n    return FastComponent(component, component_property, ack=ack, placeholder=placeholder, label_=label_, tag=tag)\n</code></pre>"},{"location":"api/#fast_dash.fastdash","title":"<code>fastdash(_callback_fn=None, *, layout='sidebar', mosaic=None, inputs=None, outputs=None, output_labels='infer', title=None, title_image_path=None, subheader=None, github_url=None, linkedin_url=None, twitter_url=None, navbar=True, footer=True, about=True, theme=None, update_live=False, port=8080, mode=None, minimal=False, disable_logs=False, scale_height=1, run_kwargs=dict(), kwargs)</code>","text":"<p>Function decorator / wrapper for Fast Dash.</p> <p>Parameters:</p> Name Type Description Default <code>callback_fn</code> <code>func</code> <p>Python function that Fast Dash deploys.             This function guides the behavior of and interaction between input and output components.</p> required <code>layout</code> <code>str</code> <p>App layout style. Currently supports 'base' and 'sidebar'. Defaults to sidebar.</p> <code>'sidebar'</code> <code>mosaic</code> <code>str</code> <p>Mosaic array layout, if sidebar layout is selected.</p> <code>None</code> <code>inputs</code> <code>Fast component, list of Fast components</code> <p>Components to represent inputs of the callback function.            Defaults to None. If <code>None</code>, Fast Dash attempts to infer the best components from callback function's type             hints and default values. In the absence of type hints, default components are all <code>Text</code>.</p> <code>None</code> <code>outputs</code> <code>Fast component, list of Fast components</code> <p>Components to represent outputs of the callback function.            Defaults to None. If <code>None</code>, Fast Dash attempts to infer the best components from callback function's type hints.            In the absence of type hints, default components are all <code>Text</code>.</p> <code>None</code> <code>output_labels(list</code> <code>of string labels or \"infer\" or None</code> <p>Labels given to the output components. If None, inputs are            set labeled integers starting at 1 (Output 1, Output 2, and so on). If \"infer\", labels are inferred from the function            signature. Defaults to infer.</p> required <code>title</code> <code>str</code> <p>Title given to the app. If <code>None</code>, function name (assumed to be in snake case)            is converted to title case. Defaults to None.</p> <code>None</code> <code>title_image_path</code> <code>str</code> <p>Path (local or URL) of the app title image. Defaults to None.</p> <code>None</code> <code>subheader</code> <code>str</code> <p>Subheader of the app, displayed below the title image and title            If <code>None</code>, Fast Dash tries to use the callback function's docstring instead. Defaults to None.</p> <code>None</code> <code>github_url</code> <code>str</code> <p>GitHub URL for branding. Displays a GitHub logo in the navbar, which takes users to the            specified URL. Defaults to None.</p> <code>None</code> <code>linkedin_url</code> <code>str</code> <p>LinkedIn URL for branding Displays a LinkedIn logo in the navbar, which takes users to the            specified URL. Defaults to None.</p> <code>None</code> <code>twitter_url</code> <code>str</code> <p>Twitter URL for branding. Displays a Twitter logo in the navbar, which takes users to the            specified URL. Defaults to None.</p> <code>None</code> <code>navbar</code> <code>bool</code> <p>Display navbar. Defaults to True.</p> <code>True</code> <code>footer</code> <code>bool</code> <p>Display footer. Defaults to True.</p> <code>True</code> <code>about</code> <code>Union[str, bool]</code> <p>App description to display on clicking the <code>About</code> button. If True, content is inferred from            the docstring of the callback function. If string, content is used directly as markdown.             <code>About</code> is hidden if False or None. Defaults to True.</p> <code>True</code> <code>theme</code> <code>str</code> <p>Apply theme to the app.All available themes can be found at https://bootswatch.com/. Defaults to JOURNAL. </p> <code>None</code> <code>update_live</code> <code>bool</code> <p>Enable hot reloading. If the number of inputs is 0, this is set to True automatically. Defaults to False.</p> <code>False</code> <code>port</code> <code>int</code> <p>Port to which the app should be deployed. Defaults to 8080.</p> <code>8080</code> <code>mode</code> <code>str</code> <p>Mode in which to launch the app. Acceptable options are <code>None</code>, <code>jupyterlab</code>, <code>inline</code>, 'external`.            Defaults to None.</p> <code>None</code> <code>minimal</code> <code>bool</code> <p>Display minimal version by hiding navbar, title, title image, subheader and footer. Defaults to False.</p> <code>False</code> <code>disable_logs</code> <code>bool</code> <p>Hide app logs. Sets logger level to <code>ERROR</code>. Defaults to False.</p> <code>False</code> <code>scale_height</code> <code>float</code> <p>Height of the app container is enlarged as a multiple of this. Defaults to 1.</p> <code>1</code> <code>run_kwargs</code> <code>dict</code> <p>All values from this variable are passed to Dash's <code>.run</code> method.</p> <code>dict()</code> Source code in <code>fast_dash/fast_dash.py</code> <pre><code>def fastdash(\n    _callback_fn=None,\n    *,\n    layout=\"sidebar\",\n    mosaic=None,\n    inputs=None,\n    outputs=None,\n    output_labels=\"infer\",\n    title=None,\n    title_image_path=None,\n    subheader=None,\n    github_url=None,\n    linkedin_url=None,\n    twitter_url=None,\n    navbar=True,\n    footer=True,\n    about=True,\n    theme=None,\n    update_live=False,\n    port=8080,\n    mode=None,\n    minimal=False,\n    disable_logs=False,\n    scale_height=1,\n    run_kwargs=dict(),\n    **kwargs\n):\n\"\"\"\n    Function decorator / wrapper for Fast Dash.\n\n    Args:\n        callback_fn (func): Python function that Fast Dash deploys. \\\n            This function guides the behavior of and interaction between input and output components.\n\n        layout (str, optional): App layout style. Currently supports 'base' and 'sidebar'. Defaults to sidebar.\n\n        mosaic (str): Mosaic array layout, if sidebar layout is selected.\n\n        inputs (Fast component, list of Fast components, optional): Components to represent inputs of the callback function.\\\n            Defaults to None. If `None`, Fast Dash attempts to infer the best components from callback function's type \\\n            hints and default values. In the absence of type hints, default components are all `Text`.\n\n        outputs (Fast component, list of Fast components, optional): Components to represent outputs of the callback function.\\\n            Defaults to None. If `None`, Fast Dash attempts to infer the best components from callback function's type hints.\\\n            In the absence of type hints, default components are all `Text`.\n\n        output_labels(list of string labels or \"infer\" or None, optional): Labels given to the output components. If None, inputs are\\\n            set labeled integers starting at 1 (Output 1, Output 2, and so on). If \"infer\", labels are inferred from the function\\\n            signature. Defaults to infer.\n\n        title (str, optional): Title given to the app. If `None`, function name (assumed to be in snake case)\\\n            is converted to title case. Defaults to None.\n\n        title_image_path (str, optional): Path (local or URL) of the app title image. Defaults to None.\n\n        subheader (str, optional): Subheader of the app, displayed below the title image and title\\\n            If `None`, Fast Dash tries to use the callback function's docstring instead. Defaults to None.\n\n\n        github_url (str, optional): GitHub URL for branding. Displays a GitHub logo in the navbar, which takes users to the\\\n            specified URL. Defaults to None.\n\n        linkedin_url (str, optional): LinkedIn URL for branding Displays a LinkedIn logo in the navbar, which takes users to the\\\n            specified URL. Defaults to None.\n\n        twitter_url (str, optional): Twitter URL for branding. Displays a Twitter logo in the navbar, which takes users to the\\\n            specified URL. Defaults to None.\n\n        navbar (bool, optional): Display navbar. Defaults to True.\n\n        footer (bool, optional): Display footer. Defaults to True.\n\n        about (Union[str, bool], optional): App description to display on clicking the `About` button. If True, content is inferred from\\\n            the docstring of the callback function. If string, content is used directly as markdown. \\\n            `About` is hidden if False or None. Defaults to True.\n\n        theme (str, optional): Apply theme to the app.All available themes can be found at https://bootswatch.com/. Defaults to JOURNAL. \n\n        update_live (bool, optional): Enable hot reloading. If the number of inputs is 0, this is set to True automatically. Defaults to False.\n\n        port (int, optional): Port to which the app should be deployed. Defaults to 8080.\n\n        mode (str, optional): Mode in which to launch the app. Acceptable options are `None`, `jupyterlab`, `inline`, 'external`.\\\n            Defaults to None.\n\n        minimal (bool, optional): Display minimal version by hiding navbar, title, title image, subheader and footer. Defaults to False.\n\n        disable_logs (bool, optional): Hide app logs. Sets logger level to `ERROR`. Defaults to False.\n\n        scale_height (float, optional): Height of the app container is enlarged as a multiple of this. Defaults to 1.\n\n        run_kwargs (dict, optional): All values from this variable are passed to Dash's `.run` method.\n        \"\"\"\n\n    def decorator_fastdash(callback_fn):\n        \"Decorator for callback_fn\"\n\n        @functools.wraps(callback_fn)\n        def wrapper_fastdash(**kwargs):\n            app = FastDash(callback_fn=callback_fn, **kwargs)\n            app.run()\n            return callback_fn\n\n        return wrapper_fastdash(\n            layout=layout,\n            mosaic=mosaic,\n            inputs=inputs,\n            outputs=outputs,\n            output_labels=output_labels,\n            title=title,\n            title_image_path=title_image_path,\n            subheader=subheader,\n            github_url=github_url,\n            linkedin_url=linkedin_url,\n            twitter_url=twitter_url,\n            navbar=navbar,\n            footer=footer,\n            about=about,\n            theme=theme,\n            update_live=update_live,\n            mode=mode,\n            port=port,\n            minimal=minimal,\n            disable_logs=disable_logs,\n            scale_height=scale_height,\n            run_kwargs=run_kwargs,\n            **kwargs\n        )\n\n    # If the decorator is called with arguments\n    if _callback_fn is None:\n        return decorator_fastdash\n    # If the decorator is called without arguments. Use default input and output values\n    else:\n        return decorator_fastdash(_callback_fn)\n</code></pre>"},{"location":"authors/","title":"Credits","text":""},{"location":"authors/#development-lead","title":"Development Lead","text":"<ul> <li>Kedar Dabhadkar kedar@fastdash.app</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<p>None yet. Why not be the first?</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/dkedar7/fast_dash/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>Fast Dash could always use more documentation, whether as part of the official Fast Dash docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/dkedar7/fast_dash/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>fast_dash</code> for local development.</p> <ol> <li>Fork the <code>fast_dash</code> repo on GitHub.</li> <li>Clone your fork locally <pre><code>    $ git clone git@github.com:your_name_here/fast_dash.git\n</code></pre></li> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <p><pre><code>    $ poetry install -E test -E doc -E dev\n</code></pre> 5. Create a branch for local development: <pre><code>    $ git checkout -b name-of-your-bugfix-or-feature\n</code></pre>    Now you can make your changes locally.  6. When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox: <pre><code>    $ tox\n</code></pre> 7. Commit your changes and push your branch to GitHub: <pre><code>    $ git add .\n    $ git commit -m \"Your detailed description of your changes.\"\n    $ git push origin name-of-your-bugfix-or-feature\n</code></pre> 8. Submit a pull request through the GitHub website.</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.8, 3.9, 3.10, 3.11 and for PyPy. Check    https://github.com/dkedar7/fast_dash/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<p><pre><code>    $ pytest tests.test_fast_dash\n</code></pre> To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"History","text":""},{"location":"history/#027-2023-10-18","title":"0.2.7 (2023-10-18)","text":""},{"location":"history/#features","title":"Features","text":"<ul> <li>New component: <code>Table</code></li> <li> <ul> <li>Fast components are callable to update attributes. For example, to update the <code>page_size</code> attribute of <code>Table</code>, do <code>Table(page_size=20)</code>. At the same time, Fast Components can also be used as non-callable objects.</li> </ul> </li> <li>Pandas DataFrame is rendered as a <code>Table</code>.</li> <li>\"About\" button displays the function docstring in parse markdown. New utility function to extract function docstring has been incorporated for this feature. This is, however, still experimental.</li> <li>Documentation upates, new \"Usage Patterns\" page.</li> <li>New tests.</li> <li>Fast Dash now supports Python 3.11.</li> </ul>"},{"location":"history/#deprecations","title":"Deprecations","text":"<ul> <li>Support for Python 3.7 has been deprecated.</li> </ul>"},{"location":"history/#026-2023-09-04","title":"0.2.6 (2023-09-04)","text":""},{"location":"history/#features_1","title":"Features","text":"<ul> <li>New chat component! Setting the output data type to <code>Chat</code> and returning a dictionary displays a chat component.</li> <li>Introduced a transformation step before passing inputs to the callback. This allows converting non-native inputs to native data types. For example, passing a PIL.Image as input data tyoe hint doesn't need converting it to a base64 string.</li> <li>Errors are displayed as notifications.</li> <li>Updated documentation and tests. </li> </ul>"},{"location":"history/#025-2023-08-13","title":"0.2.5 (2023-08-13)","text":""},{"location":"history/#improvements","title":"Improvements","text":"<ul> <li>Fix: <code>update_live</code> is automatically set to <code>True</code> if the callback function doesn't require any inputs.</li> </ul>"},{"location":"history/#024-2023-08-12","title":"0.2.4 (2023-08-12)","text":""},{"location":"history/#improvements_1","title":"Improvements","text":"<ul> <li>Improve responsiveness on mobile views.</li> <li><code>outputs</code> argument overrides callback function output hints.</li> <li>Improve pytest coverage.</li> </ul>"},{"location":"history/#023-2023-08-01","title":"0.2.3 (2023-08-01)","text":""},{"location":"history/#features_2","title":"Features","text":"<ul> <li>Dash components can be used as type hints directly. They are converted to Fast components during app initialization.</li> <li>Added a mosaic layout example to README.</li> <li><code>dash</code> can be imported from <code>fast_dash</code> like this: <code>from fast_dash import dash</code>.</li> </ul>"},{"location":"history/#022-2023-07-26","title":"0.2.2 (2023-07-26)","text":""},{"location":"history/#features_3","title":"Features","text":"<ul> <li>New example: Chat over docs with Embedchain.</li> </ul>"},{"location":"history/#improvements_2","title":"Improvements","text":"<ul> <li>Squashed a bug that was preventing the submit and reset buttons to sync with each other. The result is a more stable deploy using callback context.</li> </ul>"},{"location":"history/#021-2023-07-23","title":"0.2.1 (2023-07-23)","text":""},{"location":"history/#features_4","title":"Features","text":"<ul> <li>Infer output labels from the callback function or specify the `output_labels`` argument</li> <li>Show overlay when loading outputs</li> <li>Use dmc.Burger icon instead of open, close icons. Allows for a clearner sidebar open/close UX</li> <li>New examples</li> </ul>"},{"location":"history/#improvements_3","title":"Improvements","text":"<ul> <li>[Bug] Components are now initialized with the desired height</li> <li>Sidebar collapse burger is not supported in minimal layout</li> <li>Replace branding text with icon</li> <li>New pytests to improve coverage</li> </ul>"},{"location":"history/#020-2023-07-02","title":"0.2.0 (2023-07-02)","text":""},{"location":"history/#features_5","title":"Features","text":"<ul> <li>Enable sidebar layout.</li> <li>Mosaic to build custom layouts.</li> <li>Collapsible sidebar.</li> </ul>"},{"location":"history/#improvements_4","title":"Improvements","text":"<ul> <li>Sidebar layout improvements to allow flex sizing of components.</li> <li>Unit test updates to support the latest tox and poetry versions.</li> </ul>"},{"location":"history/#017-2022-08-21","title":"0.1.7 (2022-08-21)","text":"<ul> <li>Introduce Fast Dash decorator (<code>fastdash</code>) for automatic and quick deployment.</li> <li>Autoinfer input and output components from type hints and default values.</li> <li>Autoinfer title and subheader by inspecting the callback function.</li> <li>New test cases.</li> <li>Modified documentation layout and content.</li> <li>New GitHub Actions workflow to publish documentation only.</li> </ul>"},{"location":"history/#016-2022-05-09","title":"0.1.6 (2022-05-09)","text":"<ul> <li>Navbar and footer are not thinner than before, which makes them less distracting ;)</li> <li>They no longer stick to the top and bottom respectively. Scrolling on the page makes the navbar dissappear!</li> <li>Update live: New live update option! Setting the argument <code>update_live=True</code> removes <code>Submit</code> and <code>Clear</code> buttons. Any action updates the app right away.</li> <li>New spinners: Finally, Fast Dash now has loading spinners to indicate loading outputs. This comes in handy when executing long running scripts.</li> </ul>"},{"location":"history/#015-2022-04-02","title":"0.1.5 (2022-04-02)","text":"<ul> <li>Add examples: Object detection, molecule 3D viewer and UI updates to the existing examples.</li> <li>Easier fastification: Fastify now allows using a complete Dash component as the first argument.</li> <li>Tests: Increase pytest coverage to 95%.</li> </ul>"},{"location":"history/#014-2022-03-21","title":"0.1.4 (2022-03-21)","text":"<ul> <li>New component property allows setting \"acknowledgment\" component!</li> <li>Default app title is 'Prototype'.</li> <li>New UploadImage component uses another html.Img component as acknowledgment.</li> <li>Added a new Neural Style Transfer example.</li> <li>Added examples to pytest cases.</li> </ul>"},{"location":"history/#013-2022-03-11","title":"0.1.3 (2022-03-11)","text":"<ul> <li>Added 3 new examples.</li> <li>Make <code>navbar</code> and <code>footer</code> removable from the app UI.</li> <li>Updated documentation structure.</li> <li>Added Google Cloud Run deployment docs.</li> </ul>"},{"location":"history/#012-2022-03-06","title":"0.1.2 (2022-03-06)","text":"<ul> <li>Supports usage of the same FastComponent multiple times via deepcopy.</li> <li>Correct documentation typos and examples.</li> <li>Added text-to-text examples.</li> <li>Modifications to the Fastify component.</li> </ul>"},{"location":"history/#011-2022-02-28","title":"0.1.1 (2022-02-28)","text":"<ul> <li>First wide release.</li> <li>Adding input, output image functionality.</li> <li>Added mkdocs documentation.</li> </ul>"},{"location":"history/#010-2022-01-29","title":"0.1.0 (2022-01-29)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install Fast Dash, run this command in your terminal:</p> <pre><code>$ pip install fast-dash\n</code></pre> <p>This is the preferred method to install Fast Dash, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for Fast Dash can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/dkedar7/fast_dash\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/dkedar7/fast_dash/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#install-fast-dash","title":"Install Fast Dash","text":"<p>Let's start by installing Fast Dash: <pre><code>pip install fast-dash\n</code></pre></p>"},{"location":"quickstart/#simple-example","title":"Simple Example","text":"<p>Here's the simple text to text function from the home page again.</p> <pre><code>from fast_dash import fastdash\n\n@fastdash\ndef text_to_text_function(input_text):\n    return input_text\n</code></pre> <p>This should spin up your first Fast Dash app!</p> <p> </p> Simple example app"},{"location":"quickstart/#chatbot-example","title":"Chatbot example","text":"<p>Fast Dash also offers many in-built components to make development easier.  These can be used as data type hints. Here's a dummy chatbot example.</p> <pre><code>from fast_dash import fastdash, Chat\n\n@fastdash(theme=\"sketchy\")\ndef virtual_assistant(query: str) -&gt; Chat:\n    response = \"I am Groot.\"\n    chat = dict(query=query, response=response)\n    return chat\n</code></pre> <p> </p> Simple chatbot app"},{"location":"quickstart/#image-to-image-example","title":"Image to image example","text":"<p>Fast Dash makes it very easy to work with different types of data types and components.  For example, here's how to build an app that receives an uploaded image and returns the same image. We can, of course, write any image analysis transformation we want.</p> <pre><code>from fast_dash import fastdash\nfrom PIL import Image\n\n@fastdash\ndef image_to_image(image: Image.Image) -&gt; Image.Image:\n    \"Example of an image to image app with Fast Dash\"\n    return image\n</code></pre> <p>This is how the deployed app looks:</p> <p> </p> Simple image to image example app"},{"location":"quickstart/#what-else-is-possible","title":"What else is possible","text":"<p>There are many customizations that you can make with your app. These include:</p> <ul> <li>Choose from different themes</li> <li>Use any Dash component in your app</li> <li>Add custom branding and social media icons</li> <li>Customize pre-built components</li> <li>Live reload</li> <li>Minimal view</li> <li>JupyterLab inline and embedded views</li> </ul> <p>By tweaking these configurations, you can easily build web applications for a variety of use cases!</p>"},{"location":"quickstart/#examples","title":"Examples","text":"<p>See the examples page for more executable examples.</p>"},{"location":"Examples/01_simple_text_to_text/","title":"1. Simple text to text","text":"<p>This notebook is optimized to run in Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install fast-dash jupyter_dash\n</pre> # !pip install fast-dash jupyter_dash In\u00a0[1]: Copied! <pre>from fast_dash import fastdash\n</pre> from fast_dash import fastdash In\u00a0[1]: Copied! <pre>@fastdash(mode='inline', port=5000)\ndef text_to_text_function(input_text):\n    return input_text\n</pre> @fastdash(mode='inline', port=5000) def text_to_text_function(input_text):     return input_text"},{"location":"Examples/02_translate_to_multiple_languages/","title":"2. Translate to multiple languages","text":"<p>This notebook is optimized to run in Google Colab.</p> In\u00a0[\u00a0]: Copied! <pre>!pip install fast-dash jupyter_dash\n</pre> !pip install fast-dash jupyter_dash In\u00a0[1]: Copied! <pre># This demo uses Hugging Face API inference. To use this, get your token from https://huggingface.co/settings/tokens and paste it below.\nimport os\nos.environ[\"HF_TOKEN\"] = \"hf_xxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n</pre>  # This demo uses Hugging Face API inference. To use this, get your token from https://huggingface.co/settings/tokens and paste it below. import os os.environ[\"HF_TOKEN\"] = \"hf_xxxxxxxxxxxxxxxxxxxxxxxxxxx\" In\u00a0[2]: Copied! <pre>from fast_dash import fastdash\nimport requests\n\nAPI_URL = \"https://api-inference.huggingface.co/models/t5-base\"\nheaders = {\"Authorization\": f\"Bearer {os.environ.get('HF_TOKEN')}\"}\n</pre> from fast_dash import fastdash import requests  API_URL = \"https://api-inference.huggingface.co/models/t5-base\" headers = {\"Authorization\": f\"Bearer {os.environ.get('HF_TOKEN')}\"} In\u00a0[4]: Copied! <pre>@fastdash(mode='inline', port=5000)\ndef translate_to_multiple_languages(text: str = \"Translate this text to another language\", language: str = [\"German\", \"French\", \"Romanian\"]):\n    \"Uses  the T5 Base model from Hugging Face. May give incorrect results.\"\n\t\n    payload = {\"inputs\": f\"translate English to {language}: {text}\"}\n    response = requests.post(API_URL, headers=headers, json=payload)\n    translation = response.json()[0]['translation_text'] if 'translation_text' in response.json()[0] else str(response.json())\n    return translation\n</pre> @fastdash(mode='inline', port=5000) def translate_to_multiple_languages(text: str = \"Translate this text to another language\", language: str = [\"German\", \"French\", \"Romanian\"]):     \"Uses  the T5 Base model from Hugging Face. May give incorrect results.\" \t     payload = {\"inputs\": f\"translate English to {language}: {text}\"}     response = requests.post(API_URL, headers=headers, json=payload)     translation = response.json()[0]['translation_text'] if 'translation_text' in response.json()[0] else str(response.json())     return translation"},{"location":"Examples/03_chat_over_documents/","title":"3. Chat over documents with Embedchain","text":"<p>This notebook is optimized to run in Google Colab.</p> In\u00a0[1]: Copied! <pre>!pip install fast-dash embedchain jupyter_dash\n</pre> !pip install fast-dash embedchain jupyter_dash In\u00a0[2]: Copied! <pre>import os\nfrom fast_dash import fastdash, Fastify, dcc, dmc\n\nfrom embedchain import App\nfrom embedchain.config import QueryConfig\n\nfrom string import Template\n</pre> import os from fast_dash import fastdash, Fastify, dcc, dmc  from embedchain import App from embedchain.config import QueryConfig  from string import Template In\u00a0[3]: Copied! <pre># Define app configurations\nPROMPT = Template(\n\"\"\"Use the given context to answer the question at the end.\nIf you don't know the answer, say so, but don't try to make one up.\nAt the end of the answer, also give the sources as a bulleted list.\nDisplay the answer as markdown text.\n\nContext: $context\n\nQuery: $query\n\nAnswer:\"\"\"\n)\nquery_config = QueryConfig(template=PROMPT)\n</pre> # Define app configurations PROMPT = Template(     \"\"\"Use the given context to answer the question at the end. If you don't know the answer, say so, but don't try to make one up. At the end of the answer, also give the sources as a bulleted list. Display the answer as markdown text.  Context: $context  Query: $query  Answer:\"\"\" ) query_config = QueryConfig(template=PROMPT) In\u00a0[4]: Copied! <pre># Define components\nopenai_api_key_component = dmc.PasswordInput(\n    placeholder=\"API Key\",\n    description=\"Get yours at https://platform.openai.com/account/api-keys\",\n    required=True,\n)\n\nweb_page_urls_component = dmc.MultiSelect(\n    description=\"Include all the reference web URLs\",\n    placeholder=\"Enter URLs separated by commas\",\n    searchable=True,\n    creatable=True,\n)\n\ntext_component = dmc.Textarea(\n    placeholder=\"Custom text\",\n    autosize=True,\n    minRows=4,\n    description=\"Any additional information that could be useful\",\n)\n\nquery_component = dmc.Textarea(\n    placeholder=\"Write your query here\",\n    autosize=True,\n    minRows=4,\n    required=True,\n    description=\"Write your query here\",\n)\n\nanswer_component = dcc.Markdown(\n    style={\"text-align\": \"left\", \"padding\": \"1%\"}, link_target=\"_blank\"\n)\n</pre> # Define components openai_api_key_component = dmc.PasswordInput(     placeholder=\"API Key\",     description=\"Get yours at https://platform.openai.com/account/api-keys\",     required=True, )  web_page_urls_component = dmc.MultiSelect(     description=\"Include all the reference web URLs\",     placeholder=\"Enter URLs separated by commas\",     searchable=True,     creatable=True, )  text_component = dmc.Textarea(     placeholder=\"Custom text\",     autosize=True,     minRows=4,     description=\"Any additional information that could be useful\", )  query_component = dmc.Textarea(     placeholder=\"Write your query here\",     autosize=True,     minRows=4,     required=True,     description=\"Write your query here\", )  answer_component = dcc.Markdown(     style={\"text-align\": \"left\", \"padding\": \"1%\"}, link_target=\"_blank\" ) In\u00a0[4]: Copied! <pre># Define the callback function and deploy!\n\n@fastdash(mode=\"inline\", port=5000)\ndef explore_your_knowledge_base(\n    openai_api_key: openai_api_key_component,\n    web_page_urls: web_page_urls_component,\n    youtube_urls: web_page_urls_component,\n    pdf_urls: web_page_urls_component,\n    text: text_component,\n    query: query_component,\n) -&gt; answer_component:\n\"\"\"\n    Input your sources and let GPT4 find answers. Built with Fast Dash.\n    This app uses embedchain.ai, which abstracts the entire process of loading and chunking datasets, creating embeddings, and storing them in a vector database.\n    Embedchain itself uses Langchain and OpenAI's ChatGPT API.\n    \"\"\"\n    os.environ[\"OPENAI_API_KEY\"] = openai_api_key\n\n    try:\n        app = App()\n\n        if not openai_api_key:\n            return \"Did you forget adding your OpenAI API key? If you don't have one, you can get it [here](https://platform.openai.com/account/api-keys).\"\n        \n        if not query:\n            return \"Did you forget writing your query in the query box?\"\n        \n        if web_page_urls:\n            [app.add(\"web_page\", url) for url in web_page_urls]\n\n        if youtube_urls:\n            [app.add(\"youtube_video\", url) for url in youtube_urls]\n\n        if pdf_urls:\n            [app.add(\"pdf_file\", url) for url in pdf_urls]\n\n        if text:\n            app.add_local(\"text\", text)\n\n        answer = app.query(query, query_config)\n\n    except Exception as e:\n        answer = \"Oops, something went wrong! Please try again later or make a suggestion [here](https://github.com/dkedar7/embedchain-fastdash/issues).\"\n\n    return answer\n</pre> # Define the callback function and deploy!  @fastdash(mode=\"inline\", port=5000) def explore_your_knowledge_base(     openai_api_key: openai_api_key_component,     web_page_urls: web_page_urls_component,     youtube_urls: web_page_urls_component,     pdf_urls: web_page_urls_component,     text: text_component,     query: query_component, ) -&gt; answer_component:     \"\"\"     Input your sources and let GPT4 find answers. Built with Fast Dash.     This app uses embedchain.ai, which abstracts the entire process of loading and chunking datasets, creating embeddings, and storing them in a vector database.     Embedchain itself uses Langchain and OpenAI's ChatGPT API.     \"\"\"     os.environ[\"OPENAI_API_KEY\"] = openai_api_key      try:         app = App()          if not openai_api_key:             return \"Did you forget adding your OpenAI API key? If you don't have one, you can get it [here](https://platform.openai.com/account/api-keys).\"                  if not query:             return \"Did you forget writing your query in the query box?\"                  if web_page_urls:             [app.add(\"web_page\", url) for url in web_page_urls]          if youtube_urls:             [app.add(\"youtube_video\", url) for url in youtube_urls]          if pdf_urls:             [app.add(\"pdf_file\", url) for url in pdf_urls]          if text:             app.add_local(\"text\", text)          answer = app.query(query, query_config)      except Exception as e:         answer = \"Oops, something went wrong! Please try again later or make a suggestion [here](https://github.com/dkedar7/embedchain-fastdash/issues).\"      return answer"},{"location":"Examples/04_land_cover_map_with_geemap/","title":"4. US land cover map with Geemap","text":"<p>This notebook is optimized to run in Google Colab.</p> <p>We'll use the amazing Geemap library for this demo. Learn more about Geemap at https://geemap.org/.</p> In\u00a0[1]: Copied! <pre>!pip install fast-dash geemap jupyter_dash\n</pre> !pip install fast-dash geemap jupyter_dash In\u00a0[2]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n\nfrom fast_dash import fastdash, html, Fastify\n</pre> import ee import geemap.foliumap as geemap  from fast_dash import fastdash, html, Fastify In\u00a0[\u00a0]: Copied! <pre># Authenticate Google Earth Engine\nee.Authenticate()\n</pre> # Authenticate Google Earth Engine ee.Authenticate() In\u00a0[3]: Copied! <pre># Define years over which we'll compare land cover\nyears = ['2001', '2004', '2006', '2008', '2011', '2013', '2016', '2019']\n\n# Using Fastify, Fast Dash allows making any Dash component suitable with Fast Dash\niframe_component = Fastify(component=html.Iframe(height=\"100%\"), \n                           component_property=\"srcdoc\")\n</pre> # Define years over which we'll compare land cover years = ['2001', '2004', '2006', '2008', '2011', '2013', '2016', '2019']  # Using Fastify, Fast Dash allows making any Dash component suitable with Fast Dash iframe_component = Fastify(component=html.Iframe(height=\"100%\"),                             component_property=\"srcdoc\") In\u00a0[4]: Copied! <pre># Build and deploy!\n# If running locally, feel free to drop the mode and port arguments.\n\n@fastdash(theme=\"Zephyr\", mode=\"inline\", port=5000)\ndef compare_land_cover(year_of_left_layer: str = years, \n                       year_of_right_layer: str = years) -&gt; iframe_component:\n    \"Compare how land cover in the US changed over the years\"\n\n    # Geemap code. Ref: https://huggingface.co/spaces/giswqs/geemap/blob/main/app.py\n    Map = geemap.Map(center=(40, -100), zoom=4, height=600)\n\n    nlcd_left = ee.Image(\n        f\"USGS/NLCD_RELEASES/2019_REL/NLCD/{year_of_left_layer}\"\n    ).select(\"landcover\")\n    nlcd_right = ee.Image(\n        f\"USGS/NLCD_RELEASES/2019_REL/NLCD/{year_of_right_layer}\"\n    ).select(\"landcover\")\n\n    left_layer = geemap.ee_tile_layer(nlcd_left, {}, f\"NLCD {year_of_left_layer}\")\n    right_layer = geemap.ee_tile_layer(nlcd_right, {}, f\"NLCD {year_of_right_layer}\")\n\n    Map.split_map(left_layer, right_layer)\n\n    # Convert to HTML\n    land_cover_map = Map.to_html()\n\n    return land_cover_map\n</pre> # Build and deploy! # If running locally, feel free to drop the mode and port arguments.  @fastdash(theme=\"Zephyr\", mode=\"inline\", port=5000) def compare_land_cover(year_of_left_layer: str = years,                         year_of_right_layer: str = years) -&gt; iframe_component:     \"Compare how land cover in the US changed over the years\"      # Geemap code. Ref: https://huggingface.co/spaces/giswqs/geemap/blob/main/app.py     Map = geemap.Map(center=(40, -100), zoom=4, height=600)      nlcd_left = ee.Image(         f\"USGS/NLCD_RELEASES/2019_REL/NLCD/{year_of_left_layer}\"     ).select(\"landcover\")     nlcd_right = ee.Image(         f\"USGS/NLCD_RELEASES/2019_REL/NLCD/{year_of_right_layer}\"     ).select(\"landcover\")      left_layer = geemap.ee_tile_layer(nlcd_left, {}, f\"NLCD {year_of_left_layer}\")     right_layer = geemap.ee_tile_layer(nlcd_right, {}, f\"NLCD {year_of_right_layer}\")      Map.split_map(left_layer, right_layer)      # Convert to HTML     land_cover_map = Map.to_html()      return land_cover_map"},{"location":"Examples/05_water_indices_with_spyndex/","title":"5. Global map of water indices with Geemap","text":"<p>This notebook is optimized to run in Google Colab. An interactive demo of this example is deployed here.</p> In\u00a0[1]: Copied! <pre>#!pip install geemap spyndex fast-dash\n</pre> #!pip install geemap spyndex fast-dash In\u00a0[1]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\nimport spyndex\n\nimport datetime\nimport pandas as pd\nfrom fast_dash import FastDash, Fastify, html, dbc, dmc, dash\n\nee.Authenticate()\nee.Initialize()\n</pre> import ee import geemap.foliumap as geemap import spyndex  import datetime import pandas as pd from fast_dash import FastDash, Fastify, html, dbc, dmc, dash  ee.Authenticate() ee.Initialize() In\u00a0[3]: Copied! <pre>data = pd.read_csv(\"assets/gaul_data.csv\")\n</pre> data = pd.read_csv(\"assets/gaul_data.csv\") In\u00a0[4]: Copied! <pre>data.head()\n</pre> data.head() Out[4]: ADM0_NAME ADM1_NAME ADM2_NAME 0 United Republic of Tanzania Arusha Karatu 1 United Republic of Tanzania Iringa Iringa Rural 2 United Republic of Tanzania Iringa Kilolo 3 United Republic of Tanzania Manyara Mbulu 4 United Republic of Tanzania Pwani Kisarawe In\u00a0[5]: Copied! <pre>columns = [\"application_domain\", \"contributor\", \"date_of_addition\", \"long_name\", \"platforms\", \"reference\", \"short_name\"]\ntrack_index = []\n\nfor index in spyndex.indices.keys():\n    i = spyndex.indices[index]\n    track_index.append([i.application_domain,\n                        i.contributor,\n                        i.date_of_addition,\n                        i.long_name,\n                        i.platforms,\n                        i.reference,\n                        i.short_name])\n                        \nindex_df = pd.DataFrame(track_index, columns=columns)\n\nwater_indices = index_df[(index_df.application_domain == \"water\") &amp; \n                    (index_df.platforms.apply(lambda x: \"Landsat-OLI\" in x))]\n\n# Add label column\nwater_indices[\"label\"] = water_indices.apply(lambda row: f\"{row.short_name} ({row.long_name})\", axis=1)\n</pre> columns = [\"application_domain\", \"contributor\", \"date_of_addition\", \"long_name\", \"platforms\", \"reference\", \"short_name\"] track_index = []  for index in spyndex.indices.keys():     i = spyndex.indices[index]     track_index.append([i.application_domain,                         i.contributor,                         i.date_of_addition,                         i.long_name,                         i.platforms,                         i.reference,                         i.short_name])                          index_df = pd.DataFrame(track_index, columns=columns)  water_indices = index_df[(index_df.application_domain == \"water\") &amp;                      (index_df.platforms.apply(lambda x: \"Landsat-OLI\" in x))]  # Add label column water_indices[\"label\"] = water_indices.apply(lambda row: f\"{row.short_name} ({row.long_name})\", axis=1) <pre>/tmp/ipykernel_368/3195300281.py:20: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n</pre> In\u00a0[6]: Copied! <pre>water_indices.head()\n</pre> water_indices.head() Out[6]: application_domain contributor date_of_addition long_name platforms reference short_name label 2 water https://github.com/davemlz 2022-09-22 Augmented Normalized Difference Water Index [Sentinel-2, Landsat-OLI, Landsat-TM, Landsat-... https://doi.org/10.1016/j.envsoft.2021.105030 ANDWI ANDWI (Augmented Normalized Difference Water I... 8 water https://github.com/davemlz 2021-09-18 Automated Water Extraction Index [Sentinel-2, Landsat-OLI, Landsat-TM, Landsat-... https://doi.org/10.1016/j.rse.2013.08.029 AWEInsh AWEInsh (Automated Water Extraction Index) 9 water https://github.com/davemlz 2021-09-18 Automated Water Extraction Index with Shadows ... [Sentinel-2, Landsat-OLI, Landsat-TM, Landsat-... https://doi.org/10.1016/j.rse.2013.08.029 AWEIsh AWEIsh (Automated Water Extraction Index with ... 69 water https://github.com/davemlz 2022-04-20 Land Surface Water Index [Sentinel-2, Landsat-OLI, Landsat-TM, Landsat-... https://doi.org/10.1016/j.rse.2003.11.008 LSWI LSWI (Land Surface Water Index) 71 water https://github.com/davemlz 2022-01-17 Multi-Band Water Index [Sentinel-2, Landsat-OLI, Landsat-TM, Landsat-... https://doi.org/10.1016/j.jag.2018.01.018 MBWI MBWI (Multi-Band Water Index) In\u00a0[7]: Copied! <pre>def get_index_function(index_name, image_collection):\n    # Get the index function from Spyndex.\n    return spyndex.computeIndex(index=index_name,\n                     params={\"B\": image_collection.select(\"B2\"),\n                            \"G\": image_collection.select(\"B3\"),\n                            \"R\": image_collection.select(\"B4\"),\n                            \"N\": image_collection.select(\"B5\"),\n                            \"S1\": image_collection.select(\"B6\"),\n                            \"S2\": image_collection.select(\"B7\"),\n                            \"T1\": image_collection.select(\"B10\"),\n                            \"T2\": image_collection.select(\"B11\"),\n                            \"gamma\": 1,\n                            \"alpha\": 1})\n\ndef calculate_mean_index(image, region):\n    mean_value = image.reduceRegion(\n        reducer=ee.Reducer.mean(),\n        geometry=region,\n        scale=30,  # Adjust the scale according to your dataset and accuracy requirements\n        maxPixels=1e9\n    )\n    return mean_value.getInfo()\n\n# Define a color palette manually.\npalette = [\n    '000033',  # Very dark blue\n    '000066',  # Dark blue\n    '000099',  # Medium dark blue\n    '0000CC',  # Moderate blue\n    '0000FF',  # Blue\n    '3399FF',  # Lighter blue\n    '66CCFF',  # Light blue\n    '99CCFF',  # Very light blue\n    'CCE6FF'   # Extremely light blue\n]\n</pre> def get_index_function(index_name, image_collection):     # Get the index function from Spyndex.     return spyndex.computeIndex(index=index_name,                      params={\"B\": image_collection.select(\"B2\"),                             \"G\": image_collection.select(\"B3\"),                             \"R\": image_collection.select(\"B4\"),                             \"N\": image_collection.select(\"B5\"),                             \"S1\": image_collection.select(\"B6\"),                             \"S2\": image_collection.select(\"B7\"),                             \"T1\": image_collection.select(\"B10\"),                             \"T2\": image_collection.select(\"B11\"),                             \"gamma\": 1,                             \"alpha\": 1})  def calculate_mean_index(image, region):     mean_value = image.reduceRegion(         reducer=ee.Reducer.mean(),         geometry=region,         scale=30,  # Adjust the scale according to your dataset and accuracy requirements         maxPixels=1e9     )     return mean_value.getInfo()  # Define a color palette manually. palette = [     '000033',  # Very dark blue     '000066',  # Dark blue     '000099',  # Medium dark blue     '0000CC',  # Moderate blue     '0000FF',  # Blue     '3399FF',  # Lighter blue     '66CCFF',  # Light blue     '99CCFF',  # Very light blue     'CCE6FF'   # Extremely light blue ] In\u00a0[8]: Copied! <pre>country_component = dmc.Select(data=data.ADM0_NAME.unique().tolist(), \n                               value=\"United States of America\",\n                               label=\"Country of interest\",\n                               searchable=True)\n\nstate_component = dmc.Select(label=\"State, provience or an equivalent administrative unit\",\n                             value=\"New York\",\n                             searchable=True)\n\ncounty_component = dmc.Select(label=\"County, district or an equivalent administrative unit\",\n                              value=\"Albany\",\n                             searchable=True)\n\nindex_component = dmc.Select(data=water_indices.label.unique().tolist(),\n                             value=\"NDVIMNDWI (NDVI-MNDWI Model)\",\n                             searchable=True,\n                             clearable=True)\n\nmap_component = Fastify(html.Iframe(height=\"100%\"), \"srcdoc\", label_=\"aijgdi\")\n\n# Define a function that takes start_date, end_date, country, city, and index as arguments.\ndef water_spectral_indices(country: country_component,\n                        state_or_province: state_component = None,\n                        county_or_district: county_component = None,\n                        water_index: index_component = None,\n                        minimum_index_value: int = -1,\n                        maximum_index_value: int = 1) -&gt; map_component:\n\"\"\"\n    Visualize the selected water spectral index. Select your geography from the inputs to get started. Map on the left displays the median index value \\\n    for the years 2013 - 2015 and the map on the right displays median values for the years 2021-2023. Compare the two maps to understand how these values \\\n    changed over the years.\n    Learn more about the Spyndex Python library that enables this dynamic index computation [here](https://github.com/awesome-spectral-indices/spyndex).\n    :param country: The country of interest.\n    :type country: str\n    :param state_or_province: State, provience or an equivalent administrative unit.\n    :type state_or_province: str\n    :param county_or_district: County, district or an equivalent administrative unit.\n    :type county_or_district: str\n    :param water_index: Name of the water index.\n    :type water_index: str\n    :return: HTML of the leafmap object.\n    :rtype: str\n    \"\"\"\n    \n    if not state_or_province:\n        raise Exception(\"Please select a state\")\n        \n    if not county_or_district:\n        raise Exception(\"Please select a county\")\n    \n    # Load the Global Administrative Unit Layers (GAUL) dataset, which includes administrative boundaries.\n    admin_boundaries = ee.FeatureCollection('FAO/GAUL/2015/level2')\n\n    # Filter the GAUL dataset for the specified city and country.\n    geometry = admin_boundaries \\\n        .filter(ee.Filter.eq('ADM0_NAME', country)) \\\n        .filter(ee.Filter.eq('ADM1_NAME', state_or_province)) \\\n        .filter(ee.Filter.eq('ADM2_NAME', county_or_district)) \\\n        .geometry()\n        \n    # Load a satellite image collection (e.g., Landsat 8 Surface Reflectance).\n    left_image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR') \\\n        .filterBounds(geometry) \\\n        .filterDate(\"2013-01-01\", \"2015-12-31\") \\\n        .median() \\\n        .clip(geometry)\n    \n    right_image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR') \\\n        .filterBounds(geometry) \\\n        .filterDate(\"2021-01-01\", \"2023-12-31\") \\\n        .median() \\\n        .clip(geometry)\n    \n    # Get index name\n    index_name = water_indices[water_indices.label == water_index].short_name.iloc[0]\n    \n    index_function_left = get_index_function(index_name, left_image)\n    index_function_right = get_index_function(index_name, right_image)\n    \n    # Generate legend and visualization parameters\n    # Define visualization parameters using the custom palette.\n    vis_params = {\n        'min': minimum_index_value,\n        'max': maximum_index_value,\n        'palette': palette\n    }\n\n    # Calculate the range interval for each color.\n    num_colors = len(palette)\n    interval = 2.0 / num_colors\n\n    # Create the legend dictionary with range values as keys.\n    legend_dict = {}\n    for i, color in enumerate(palette):\n        # Define the range for each color.\n        range_min = round(-1 + i * interval, 2)\n        range_max = round(-1 + (i + 1) * interval, 2)\n        # Use the range as the key and the color as the value.\n        legend_dict[f'{range_min}-{range_max}'] = color\n    \n    # Visualize the spectral index using Geemap.\n    Map = geemap.Map(basemap=\"CartoDB.Positron\")\n    Map.centerObject(geometry, zoom=11)\n    \n    left_layer = geemap.ee_tile_layer(index_function_left, vis_params, f\"{index_name} 2013-2015\")\n    right_layer = geemap.ee_tile_layer(index_function_right, vis_params, f\"{index_name} 2021-2023\")\n    Map.split_map(left_layer, right_layer)\n\n    # Add a legend to the map.\n    Map.add_legend(title=\"Legend\", legend_dict=legend_dict, position='bottomright')\n    \n    comparison_map = Map.to_html()\n\n    return comparison_map\n</pre> country_component = dmc.Select(data=data.ADM0_NAME.unique().tolist(),                                 value=\"United States of America\",                                label=\"Country of interest\",                                searchable=True)  state_component = dmc.Select(label=\"State, provience or an equivalent administrative unit\",                              value=\"New York\",                              searchable=True)  county_component = dmc.Select(label=\"County, district or an equivalent administrative unit\",                               value=\"Albany\",                              searchable=True)  index_component = dmc.Select(data=water_indices.label.unique().tolist(),                              value=\"NDVIMNDWI (NDVI-MNDWI Model)\",                              searchable=True,                              clearable=True)  map_component = Fastify(html.Iframe(height=\"100%\"), \"srcdoc\", label_=\"aijgdi\")  # Define a function that takes start_date, end_date, country, city, and index as arguments. def water_spectral_indices(country: country_component,                         state_or_province: state_component = None,                         county_or_district: county_component = None,                         water_index: index_component = None,                         minimum_index_value: int = -1,                         maximum_index_value: int = 1) -&gt; map_component:          \"\"\"     Visualize the selected water spectral index. Select your geography from the inputs to get started. Map on the left displays the median index value \\     for the years 2013 - 2015 and the map on the right displays median values for the years 2021-2023. Compare the two maps to understand how these values \\     changed over the years.          Learn more about the Spyndex Python library that enables this dynamic index computation [here](https://github.com/awesome-spectral-indices/spyndex).          :param country: The country of interest.     :type country: str          :param state_or_province: State, provience or an equivalent administrative unit.     :type state_or_province: str          :param county_or_district: County, district or an equivalent administrative unit.     :type county_or_district: str          :param water_index: Name of the water index.     :type water_index: str          :return: HTML of the leafmap object.     :rtype: str     \"\"\"          if not state_or_province:         raise Exception(\"Please select a state\")              if not county_or_district:         raise Exception(\"Please select a county\")          # Load the Global Administrative Unit Layers (GAUL) dataset, which includes administrative boundaries.     admin_boundaries = ee.FeatureCollection('FAO/GAUL/2015/level2')      # Filter the GAUL dataset for the specified city and country.     geometry = admin_boundaries \\         .filter(ee.Filter.eq('ADM0_NAME', country)) \\         .filter(ee.Filter.eq('ADM1_NAME', state_or_province)) \\         .filter(ee.Filter.eq('ADM2_NAME', county_or_district)) \\         .geometry()              # Load a satellite image collection (e.g., Landsat 8 Surface Reflectance).     left_image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR') \\         .filterBounds(geometry) \\         .filterDate(\"2013-01-01\", \"2015-12-31\") \\         .median() \\         .clip(geometry)          right_image = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR') \\         .filterBounds(geometry) \\         .filterDate(\"2021-01-01\", \"2023-12-31\") \\         .median() \\         .clip(geometry)          # Get index name     index_name = water_indices[water_indices.label == water_index].short_name.iloc[0]          index_function_left = get_index_function(index_name, left_image)     index_function_right = get_index_function(index_name, right_image)          # Generate legend and visualization parameters     # Define visualization parameters using the custom palette.     vis_params = {         'min': minimum_index_value,         'max': maximum_index_value,         'palette': palette     }      # Calculate the range interval for each color.     num_colors = len(palette)     interval = 2.0 / num_colors      # Create the legend dictionary with range values as keys.     legend_dict = {}     for i, color in enumerate(palette):         # Define the range for each color.         range_min = round(-1 + i * interval, 2)         range_max = round(-1 + (i + 1) * interval, 2)         # Use the range as the key and the color as the value.         legend_dict[f'{range_min}-{range_max}'] = color          # Visualize the spectral index using Geemap.     Map = geemap.Map(basemap=\"CartoDB.Positron\")     Map.centerObject(geometry, zoom=11)          left_layer = geemap.ee_tile_layer(index_function_left, vis_params, f\"{index_name} 2013-2015\")     right_layer = geemap.ee_tile_layer(index_function_right, vis_params, f\"{index_name} 2021-2023\")     Map.split_map(left_layer, right_layer)      # Add a legend to the map.     Map.add_legend(title=\"Legend\", legend_dict=legend_dict, position='bottomright')          comparison_map = Map.to_html()      return comparison_map In\u00a0[9]: Copied! <pre>app = FastDash(water_spectral_indices, port=8001, theme=\"cosmo\", mode=\"external\")\n</pre> app = FastDash(water_spectral_indices, port=8001, theme=\"cosmo\", mode=\"external\") <pre>WARNING:root:Parsing function docstring is still an experimental feature. To reduce uncertainty, consider setting `about` to `False`.\n</pre> In\u00a0[10]: Copied! <pre># Keep only the states present in the selected country\n@app.app.callback(dash.Output(\"state_or_province\", \"data\"),\n                 dash.Input(\"country\", \"value\"))\ndef filter_states(country):\n    return sorted(data[data.ADM0_NAME == country].ADM1_NAME.unique().tolist())\n\n# Keep only the counties present in the selected country and state\n@app.app.callback(dash.Output(\"county_or_district\", \"data\"),\n                 dash.Input(\"country\", \"value\"),\n                 dash.Input(\"state_or_province\", \"value\"))\ndef filter_counties(country, state):\n    filtered_data = data.copy()\n    if country:\n        filtered_data = filtered_data[filtered_data.ADM0_NAME == country]\n        \n    if state:\n        filtered_data = filtered_data[filtered_data.ADM1_NAME == state]\n        \n    return sorted(filtered_data.ADM2_NAME.unique().tolist())\n</pre> # Keep only the states present in the selected country @app.app.callback(dash.Output(\"state_or_province\", \"data\"),                  dash.Input(\"country\", \"value\")) def filter_states(country):     return sorted(data[data.ADM0_NAME == country].ADM1_NAME.unique().tolist())  # Keep only the counties present in the selected country and state @app.app.callback(dash.Output(\"county_or_district\", \"data\"),                  dash.Input(\"country\", \"value\"),                  dash.Input(\"state_or_province\", \"value\")) def filter_counties(country, state):     filtered_data = data.copy()     if country:         filtered_data = filtered_data[filtered_data.ADM0_NAME == country]              if state:         filtered_data = filtered_data[filtered_data.ADM1_NAME == state]              return sorted(filtered_data.ADM2_NAME.unique().tolist()) In\u00a0[11]: Copied! <pre>app.run()\n</pre> app.run() <pre>Dash app running on http://127.0.0.1:8001/\n</pre>"},{"location":"Examples/05_water_indices_with_spyndex/#read-gaul-data-values","title":"Read GAUL data values\u00b6","text":""},{"location":"Examples/05_water_indices_with_spyndex/#get-a-list-of-water-indices","title":"Get a list of water indices\u00b6","text":""},{"location":"Examples/05_water_indices_with_spyndex/#define-utility-functions","title":"Define utility functions\u00b6","text":""},{"location":"Examples/05_water_indices_with_spyndex/#define-the-main-function-and-build-fast-dash-app","title":"Define the main function and build Fast Dash app\u00b6","text":""},{"location":"Examples/05_water_indices_with_spyndex/#additional-app-functionality","title":"Additional app functionality\u00b6","text":""},{"location":"Examples/neural_style_transfer/","title":"Neural style transfer","text":"<p>Coming soon ...</p>"},{"location":"User%20guide/build/","title":"10 minutes to Fast Dash","text":"<p>This quick introduction to Fast Dash is geared mainly toward new users. If you've been here before, use the table of contents to jump to a specific section.</p>"},{"location":"User%20guide/build/#principles","title":"Principles","text":"<p>Fast Dash's foundational principles</p> <p>Fast Dash operates on two foundational principles:</p> <ol> <li>Every Python-based web application originates from a singular Python function.</li> <li>A comprehensively annotated Python function encapsulates all the information necessary to generate an interactive web application.</li> </ol> <p>To obey these principles, Fast Dash reads everything about a Python function, like the function name, docstring, and input and output type hints, to automatically generate a layout and an interactive web application!</p> <p>The callback function and Fast Dash app configurations together determine how the app is deployed and the level of user interaction. A well-annotated callback function almost always ensures minimal custom tweaking of app configurations.</p> <p>Let's discuss ways to build Fast Dash apps and customize them.</p>"},{"location":"User%20guide/build/#building-your-fast-dash-app","title":"Building your Fast Dash app","text":"<p>There are two ways to build a Fast Dash app:</p> <ol> <li>Decorating Python functions with the <code>@fastdash</code> decorator</li> </ol> <p><pre><code>from fast_dash import fastdash\n\n@fastdash(...)\ndef your_function(...):\n    ...\n</code></pre> 2. Instantiating an object of the <code>FastDash</code> class</p> <pre><code>from fast_dash import FastDash\n\ndef your_function(...):\n    ...\n\napp = FastDash(callback_fn=your_function, ...)\napp.run()\n</code></pre> <p>Using the <code>@fastdash</code> decorator is the quickest way to deploy Fast Dash apps. On the other hand, the <code>FastDash</code> class gives us access to other Fast Dash internals and allows us to tweak them as we see fit.</p> <p>Whereas the <code>@fastdash</code> decorator deploys our app when defining our functions (eagerly), the <code>FastDash</code> class objects are equivalent to Flask's server objects, allowing us to deploy our app later (lazily). <code>FastDash</code> objects must be explicitly told to <code>.run()</code> to deploy them. We'll understand these differences better throughout the remainder of this document.</p> <p>Note</p> <p>Both the <code>@fastdash</code> decorator and the <code>FastDash</code> class objects are functionally equivalent. The <code>@fastdash</code> decorator is built on top of the <code>FastDash</code> class. That means any argument valid for <code>FastDash</code> object initialization can also be specified to <code>@fastdash</code>.</p> <p>Using decorators is a very convenient way to give additional abilities to a function, the callback function in our case. It also allows us to add various automations, like instant deployments!</p> <p>Let's first understand how we can build Fast Dash apps using the <code>@fastdash</code> decorator and then extend these ideas to the <code>FastDash</code> class.</p>"},{"location":"User%20guide/build/#1-fastdash-decorator","title":"1. <code>@fastdash</code> decorator","text":""},{"location":"User%20guide/build/#whats-a-decorator","title":"What's a decorator?","text":"<p>In a nutshell, Python decorators are function wrappers that enrich the functionality of Python functions. Here's an in-depth write-up on Python decorators, what they are, and how to build them. All we need to know for now is that decorators are Python functions that wrap other functions to give them extra functionality.</p> <p>The <code>@fastdash</code> decorator is also just a function (read more here about the implementation in the Modules section) that takes the callback function as the first argument and designs a web app around it. But instead of explicitly specifying the callback function as the first argument, we use this syntax instead:</p> <pre><code>@fastdash\ndef callback_function(...)\n    ...\n</code></pre>"},{"location":"User%20guide/build/#how-to-use-fastdash","title":"How to use <code>@fastdash</code>","text":"<p>After we have a Python function that runs without errors, there are only two things we need to do:</p>"},{"location":"User%20guide/build/#11-specify-the-input-and-output-type-hints","title":"1.1. Specify the input and output type hints","text":"<p>Fast Dash uses these type hints to determine which UI components to use. For example, an input with the type hint <code>int</code> will need an input that allows entering integers or a slider. Similarly, an image input will need a component to upload an image or take a photo.</p> <p>What are type hints?</p> <p>First introduced in Python 3.5, type hints are mainly meant to be used by IDEs and linters to raise data type mismatch warnings. They are not executed during runtime, and errors with type hinting don't affect the execution of the function. Read more about Python type hints here.</p> <pre><code>def your_function(a: str, \n                  b: int, \n                  c: list) -&gt; str:\n    ...\n</code></pre> <p>Fast Dash leverages this flexibility in defining type hints to allow using Dash components as hints. Read more on this in the documentation for Fast Components.</p> <p>Fast Dash understands two types of type hints\u2014one, in-built Python data type classes (<code>str</code>, <code>int</code>, <code>float</code>, <code>list</code>, <code>dict</code>, etc.), and two, Dash Components directly.</p> <p>In addition to type hints, the input arguments can also have default values. In the example below, the default value of string <code>a</code> is <code>Fast</code>, that of integer <code>b</code> is <code>5</code>, and <code>c</code> is a <code>list</code> with a default value of <code>[1, 2, 3]</code>. The function returns a single string value, as indicated by the return variable type hint (<code>-&gt; str:</code>).</p> <pre><code>def your_function(a: str = \"Fast\", \nb: int = 5, \nc: list = [1, 2, 3]) -&gt; str:\n...\n</code></pre> <p>Fast Dash determines the best components for each input using their hints and default values. Details about which combination of these values results in what components are in the patterns documentation.</p> <p>Dash components are also valid type hints for Fast Dash. Instead of depending on the hints and default values, using Dash components directly tells Fast Dash which components to use. In the example below, <code>UploadImage</code> and <code>Slider</code> are in-built Fast Component wrappers for <code>dcc.Upload</code> and <code>dcc.Slider</code> respectively. The function returns a text field, represented using the <code>html.H1</code> component by default.</p> <pre><code>from fast_dash import fastdash, dcc\n@fastdash\ndef your_function(image: dcc.Upload(...), \nnumber: dcc.Slider(...)):\n...\n</code></pre> <p>What are Dash components?</p> <p>Dash components are interactive UI components that you can use to create web applications with Dash. Dash ships with supercharged core components (<code>dash.dcc</code>), and standard HTML components (<code>dash.html</code>) suitable for almost any task and data type.</p> <p>In addition to these, there are many other community components, and those worth mentioning are:</p> <ul> <li>Dash boostrap components</li> <li>Dash mantine components</li> </ul> <p>Here's a list of many other Dash components. In fact, Dash also allows you to design your own components using Javascript-based frameworks.</p> <p>Which of these does Fast Dash support?</p> <p>Short answer: All of them!</p> <p>Fast Dash converts a few Dash components to Fast components natively. But most have to be slightly modified before they can be used in a Fast Dash app.</p> <p>For example, Fast Dash doesn't natively support automatic conversion of Dash bio components to Fast components. However, Fast Dash offers a utility function, <code>Fastify</code> that can convert any Dash component to a Fast component. Say, we wanted to use <code>dash.bio.Molecule2dViewer</code> to view a molecule:</p> <pre><code>from fast_dash import fastdash, Fastify\nfrom dashbio import Molecule2dViewer\n\nmolecule_fast_component = Fastify(component=Molecule2dViewer(), \n                                  component_property=\"modelData\")\n\ndef view_molecule(...) -&gt; molecule_fast_component:\n    ...\n</code></pre> <p>Read more about <code>Fastify</code> here.</p>"},{"location":"User%20guide/build/#12-modify-default-settings","title":"1.2. Modify default settings","text":"<p>Fast Dash allows you to customize your app by controlling various options like the theme of the app, social media branding links, and subheaders. Let's look at all these options in this section.</p>"},{"location":"User%20guide/build/#1-title","title":"1. Title","text":"<p>Fast Dash can read the name of our callback function and display it as the title at the top of the app. Function names resolve to titles the best if they are written in snake case.</p> <p>For example, <code>your_function</code> resolves to <code>Your Function</code> but <code>yourFunction</code> will resolve to <code>YourFunction</code>. For such cases, we can manually specify the title as an argument to <code>@fastdash</code>.</p> <pre><code>@fastdash(title=\"Your Function\")\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#2-subheader","title":"2. Subheader","text":"<p>The subheader shows up below the title at the top of the page in an italicized font. Fast Dash attempts to infer this from the function docstring. But we can also overwrite it with the <code>subheader</code> argument to <code>@fastdash</code>.</p> <pre><code>@fastdash(title=\"Your Function\", \nsubheader=\"Coolest Function Ever\") # Either here\ndef yourFunction(...):\n\"Coolest Function Ever\" # or here\n...\n</code></pre>"},{"location":"User%20guide/build/#3-title-image-path","title":"3. Title image path","text":"<p>Fast Dash optionally displays an icon image below the title and subheader. The image path can be set with the argument <code>title_image_path</code>.</p> <pre><code>@fastdash(title_image_path=\"https://tinyurl.com/5fw564ux\")\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#4-social-media-urls","title":"4. Social media URLs","text":"<p>We can also set social media URLs (Fast Dash supports GitHub, LinkedIn and Twitter URLs so far) in the navigation bar at the top by setting the arguments <code>github_url</code>, <code>linkedin_url</code>, and <code>twitter_url</code> respectively.</p> <pre><code>@fastdash(github_url=\"github.com/dkedar7\",\nlinkedin_url=\"linkedin.com/in/dkedar7\",\ntwitter_url=\"twitter.com/dkedar7\")\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#5-mosaic-layout","title":"5. Mosaic layout","text":"<p>When there are multiple outputs, we might want to control the layout of the output components. Inspired by Matplotlib's <code>subplot_mosaic</code>, Fast Dash allows using ASCII art arrays to control the arrangement of the output components on the screen.</p> <p>More on using mosaic layout on the common patterns page.</p>"},{"location":"User%20guide/build/#6-navbar-and-footer-visibility","title":"6. Navbar and footer visibility","text":"<p>We can hide the navbar and the footer by controlling the boolean <code>navbar</code> and <code>footer</code> arguments respectively. These are set to <code>True</code> by default.</p> <pre><code>@fastdash(navbar=False,\nfooter=False)\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#7-theme","title":"7. Theme","text":"<p>The default theme that Fast Dash uses is called <code>JOURNAL</code>, but there are more themes that Fast Dash supports. See the complete list of supported themes at bootswatch.com.</p> <pre><code>@fastdash(theme='JOURNAL')\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#8-update-live","title":"8. Update Live","text":"<p>By default, Fast Dash apps update lazily. That means once the user enters inputs, the outputs update only after they click <code>Submit</code>. But on setting the <code>update_live</code> argument to <code>True</code>, the <code>Submit</code> and <code>Reset</code> buttons disappear, and the outputs update instantaneously. This feature is also popularly known as hot reloading.</p> <pre><code>@fastdash(update_live=True)\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#9-mode","title":"9. Mode","text":"<p><code>mode</code> is an interesting setting that decides how Fast Dash apps are deployed. There are currently four supported modes. The default mode is <code>None</code>, and the other possible <code>mode</code> options specified below require the <code>jupyter-dash</code> library installed. Read more about the library here.</p> <p><code>mode=None</code></p> <p>By default, <code>mode</code> is set to <code>None</code> which deploys the app at the chosen port (default port is 8080).</p> <p><code>mode=\"JupyterLab\"</code></p> <p>When <code>mode</code> is <code>JupyterLab</code>, the app is deployed within Jupyter environments (like classic Notebook, JupyterLab, and VS Code notebooks). The app opens as a separate tab inside JupyterLab.</p> <p><code>mode=\"inline\"</code></p> <p>With this <code>mode</code>, Fast Dash uses an IFrame to display the application inline in the notebook.</p> <p><code>mode=\"External\"</code></p> <p>This behaves like the default mode with the only difference that the app runs outside your Jupyter notebook environment. Fast Dash display a link that where you can navigate to see how the deployment will look to end users after this application is depoyed to production.</p> <pre><code>@fastdash(mode='jupyterlab')\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#10-minimal","title":"10. Minimal","text":"<p>Sometimes, we might want to see how our Python functions behave without worrying about the theme or the presence of the navbar or footer. If we set <code>minimal</code> to True, Fast Dash only displays the input and output components and hides the rest.</p> <pre><code>@fastdash(minimal=True)\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#11-disable-logs","title":"11. Disable logs","text":"<p>Under the hood, setting <code>disable_logs</code> to <code>True</code> turns off the messy log output that sometimes follows a successful Fast Dash deployment. This feature comes in handy when we are deploying apps inside Jupyter environments. On the flip side, we lose a lot of useful debugging information.</p> <pre><code>@fastdash(disable_logs=True)\ndef yourFunction(...):\n    ...\n</code></pre>"},{"location":"User%20guide/build/#2-fastdash-objects","title":"2. <code>FastDash</code> objects","text":"<p>The FastDash class powers all Fast Dash automated app development and deployment. As mentioned before, all the @fastdash decorator does under the hood is instantiate a <code>FastDash</code> object and call the <code>.run()</code> method.</p> <p>In other words, all the discussion and arguments that can be passed to the <code>@fastdash</code> decorator are also valid for the <code>FastDash</code> class. But unlike the <code>@fastdash</code> decorator, <code>FastDash</code> class gives us access to other Fast Dash internals and flexibility concerning the deployment of our apps.</p> <p>Here's how to define and deploy a Fast Dash app using FastDash. Note the highlighted differences in the code.</p> <pre><code>from fast_dash import FastDash\n\ndef your_function(...):\n    ...\n\napp = FastDash(callback_fn=your_function, ...)\napp.run()\n</code></pre> <p>We can logically separate function definition and deployment and modify configurations beyond <code>FastDash</code>'s default arguments.</p> <p>For example, we can bring our own components and layout designs by altering the UI development code, which can be accessed using <code>app.app.layout</code>.</p> <p>Next, let's see the decision process that goes into building a deployable Fast Dash app and how all these configuration settings allow us to build a variety of apps!</p>"},{"location":"User%20guide/components/","title":"Fast Components","text":"<p>Fast components are the UI components that represent the input and outputs elements in a Fast Dash app. In fact, they are Dash components modified by adding a new <code>component_property</code> attribute, in addition to a few other optional properties. Fast Dash provides a <code>Fastify</code> function to transform Dash components into Fast components.</p> <p>Fast Dash borrows the concept of <code>component_property</code> from Dash. <code>component_property</code> is the answer to the question - \"Which property of a component should be assigned the value returned by the callback function?\"</p> <p>For example, if the first argument of a Fast Dash callback function is a <code>str</code>, we must represent this input using a component that allows users to enter text. Say we decide to use the <code>dbc.Input()</code> Dash component. On referring to the documentation of the component here, you'll realize that we must update the <code>value</code> property of <code>dbc.Input()</code> for it to work as expected. And therefore, when defining a Fast component for this input we would use <code>component_property=\"value\"</code>.</p> <p>We use this design and the fact that Fast Dash allows using Fast components as type hints, in addition to standard Python data types, to write a simple app that takes text entered by users as the first input.</p> <pre><code>from fast_dash import Fastify, dbc\n\ntext_input_component = Fastify(component=dbc.Input(), component_property=\"value\")\n@fastdash\ndef your_function(input_text: text_input_component, ...):\n...\n</code></pre> <p>Note</p> <p>Note that Fast Dash offers prebuilt Fast Components for common use cases. Some of them are  - <code>Text</code>: To allow entering input text. - <code>Slider</code>: For integer inputs. - <code>Upload</code>: Used to upload documents. - <code>UploadImage</code>: Special case of <code>Upload</code> used to upload images. - <code>Image</code>: Used to display image variables returned by callback functions. - <code>Graph</code>: Display Plotly graphs. - <code>Table</code>: To view Pandas dataframes.</p> <p>These can be easily imported into your script like this:</p> <pre><code>from fast_dash import Text, Slider, Upload, UploadImage, Image, Graph, Table\n</code></pre> <p>Dash components vs Fast components</p> <p>Dash components are interactive UI components that you can use to create web applications with Dash. Dash ships with supercharged core components (<code>dash.dcc</code>), and standard HTML components (<code>dash.html</code>) suitable for almost any task and data type.</p> <p>Fast components are Dash components with some additional attributes to make them suitable for use by Fast Dash.</p> <p>If you have used Dash, you will know that it requires us to specify a <code>component_property</code> argument to Dash's <code>Input</code> and <code>Output</code> methods when defining our callback functions (during runtime). In other words, we can develop Dash UI before writing our callback functions.</p> <p>On the contrary, Fast Dash infers components (when not specified) by studying the underlying callback function, particularly its type hints and default values.</p>"},{"location":"User%20guide/components/#can-dash-components-be-used-as-fast-components","title":"Can Dash components be used as Fast Components?","text":"<p>Yes!</p> <p>However, Dash components have to be converted to Fast components before Fast Dash uses them. In most cases, Fast Dash performs that conversion automatically. But in the other cases, we can easily use the <code>Fastify</code> utility function to do that conversion ourselves.</p> <p>Here's a list of all Dash components that Fast Dash natively converts to Fast components without worrying the user.</p>"},{"location":"User%20guide/components/#how-to-transform-dash-components-into-fast-components","title":"How to transform Dash components into Fast components","text":"<p>If the Dash component you want to use isn't supported by Fast Dash off the shelf or if you want to use a different <code>component_property</code> of a Dash component, then the <code>Fastify</code> function will come to your rescue.</p> <p>Use this syntax to do the conversion:</p> <pre><code>...\nfrom fastdash import Fastify\n\nfast_component = Fastify(component=dash_component, component_property=...)\n</code></pre> <p>For example, Fast Dash doesn't natively support automatic conversion of Dash bio components to Fast components. But, <code>Fastify</code> can convert it into a Fast component. Say, we wanted to use <code>dash.bio.Molecule2dViewer</code> to view a molecule:</p> <pre><code>from fast_dash import fastdash, Fastify\nfrom dashbio import Molecule2dViewer\n\nmolecule_fast_component = Fastify(component=Molecule2dViewer(), \n                                    component_property=\"modelData\")\n\n@fastdash\ndef view_molecule(...) -&gt; molecule_fast_component:\n    ...\n</code></pre>"},{"location":"User%20guide/deployment/","title":"Deployment","text":"<p>Fast Dash apps are deployed as any other Flask app. A universal and hence the recommended way to deploy is to containerize the application and then deploy it to an endpoint.</p> <p>Here're the general steps involved with the deployment process:</p> <ol> <li>Extract the Flask server from the <code>FastDash</code> app object (<code>server = app.server</code>).</li> <li>Add a <code>Dockerfile</code> in the same directory that contains the main Fast Dash app module.</li> <li>Build and run Docker container.</li> </ol> <p>The recommended directory structure is:</p> <pre><code>root\\\n- app.py\n- requirements.txt\n- Dockerfile\n- ....py (Other scripts that your Fast Dash app needs)\n- ... (Other dependencies)\n</code></pre> <p>With these steps in mind, let's see how we can deploy our simple text-to-text Fast Dash app to Google Cloud Run. We can use the same process to deploy to any service that deploys web applications as Docker containers, like Hugging Face spaces.</p>"},{"location":"User%20guide/deployment/#1-google-cloud-run","title":"1. Google Cloud Run","text":""},{"location":"User%20guide/deployment/#step-0-get-started-with-google-cloud","title":"Step 0. Get started with Google Cloud","text":"<p>Get started with Google Cloud here. If you already have an account, proceed to the console and select Cloud Run from the list of services.</p> <p>Although not mandatory, it's highly recommended to get access to the <code>gcloud</code> command line utility. The <code>gcloud</code> CLI reduces the lines of code need to deploy apps down to just one!</p>"},{"location":"User%20guide/deployment/#step-1-extract-flask-server-object","title":"Step 1. Extract Flask server object","text":"<p>Note that <code>@fastdash</code> decorators are not recommended for production deployment. So if you've been using the decorator to develop the app locally, use the <code>FastDash</code> class instead for production deployments. Then, simply define the server object with <code>app.server</code>.</p> <pre><code>...\napp = FastDash(callback_function, ...)\nserver = app.server\n</code></pre> <p><code>server</code> is the Flask object that gets deployed. We need to isolate it so we can instruct <code>gunicorn</code> in the next step to deploy it inside our Docker container.</p>"},{"location":"User%20guide/deployment/#step-3-create-dockerfile","title":"Step 3. Create <code>Dockerfile</code>","text":"<p>Create a Dockerfile in the current path and modify it to reflect the following:</p> <pre><code>FROM python:3.9-slim\n\n# Copy local code to the container image.\nADD . /app\nWORKDIR /app\n\n# Install production dependencies.\nRUN pip3 install --no-cache-dir -r requirements.txt\n\n# Deploy app using gunicorn\nCMD exec gunicorn wsgi:server --bind :$PORT\n</code></pre>"},{"location":"User%20guide/deployment/#step-4-update-requirementstxt","title":"Step 4. Update <code>requirements.txt</code>","text":"<p>Add <code>gunicorn</code> to the list of dependencies in <code>requirements.txt</code>.</p>"},{"location":"User%20guide/deployment/#step-5-deploy","title":"Step 5. Deploy! \ud83d\ude80","text":"<p>If the <code>gcloud</code> CLI was correctly installed in step 1, simply run this command from the root of your project directory:</p> <pre><code>gcloud run deploy\n</code></pre> <p>You will be asked to choose a few different settings for your deployment. Read Google Cloud Run's documentation here to understand what each of them mean.</p> <p>That's it! Google Cloud will build your app inside a Docker container and display the URL once it's ready. The entire operation can take upto five minutes for simple applications. The build time highly depends on the complexity of your app and the number of dependencies.</p>"},{"location":"User%20guide/patterns/","title":"Usage Patterns","text":"<p>Fast Dash helps build and deploy Proof of Concept (POC) applications lightning fast while having you, the innovator, write as less UI development code as possible. </p> <p>This document outlines some common Fast Dash patterns and how you can use these ideas to fastrack your deployment.</p>"},{"location":"User%20guide/patterns/#before-you-begin","title":"Before you begin","text":"<p>Never worry about web app development or deployment before you are comfortable about your main Python functionality and supporting code.</p> <p>Note</p> <p>The whole Fast Dash promise is to decrease the time needed for app development after you have written the main Python software, not distracting you from your innovation.</p> <p>So focus on the main functionality of your code and don't worry about the web app.</p> <p>After you are comfortable with your Python function ...</p>"},{"location":"User%20guide/patterns/#1-setting-input-components","title":"1. Setting input components","text":"<p>By setting the correct callback function type hints, their default values, or choosing Dash components, and built-in Fast components, you can display most common UI elements for users to enter their inputs.</p> <p>Note</p> <p>If you used the proper Python function type hinting practices, you might not have to make many changes to your code. </p> <p>Here are some examples:</p> Input is Type hint Default value Example Text Text <code>str</code> Any <code>def my_func(arg1: str)</code> Single item from a list of fixed items <code>str</code> List of allowed text items <code>def get_gdp(country: str = [\"USA\", \"Canada\", \"Mexico\"])</code> List of items and users can add their own items <code>list</code> Blank <code>def enter_web_urls(urls: list)</code> List of items and users must choose from a fixed set of items <code>list</code> List of fixed set of items <code>def enter_web_urls(urls: list = [\"google.com\", \"youtube.com\", \"facebook.com\", \"bing.com\"])</code> Numbers Number <code>int</code> or <code>float</code> Blank <code>def enter_score(score: int)</code> or <code>def enter_score(score: float)</code> Bounded number <code>int</code> or <code>float</code> List of bounds and step size in the format: <code>range(min, max, step)</code> <code>def enter_score(score: int = range(0, 10))</code> or <code>def enter_score(score: float = list(np.arange(0, 10, 0.1)))</code> Images and documents Image <code>PIL.Image.Image</code> Blank or default image (PIL format) <code>def upload_image(image: PIL.Image.Image)</code> Any document Built-in component <code>Upload</code> Blank <code>def upload_doc(doc: Upload)</code> Dates Single date <code>datetime.date</code> or <code>datetime.datetime</code> Blank or default date <code>def set_date(date: datetime.date = datetime.date(2023, 1, 1))</code>"},{"location":"User%20guide/patterns/#2-setting-output-components","title":"2. Setting output components","text":"<p>We've seen that we can set the desired input component by choosing a specific combination of input type hints and default values. Setting output components works similar to that.</p> <p>Reminder</p> <p>Return type hints in Python are written in the function description following the <code>-&gt;</code> symbol.</p> <p>For example, </p> <ul> <li><code>def my_func(...) -&gt; str</code> indicates that the first return value is a string.</li> <li><code>def my_func(...) -&gt; (str, int)</code> indicates that the first return value is a string and the second return value is an integer.</li> </ul> <p>Here's how to set the desired components using return type hints:</p> Output is Type hint Example Text <code>str</code> <code>def my_func(...) -&gt; str:</code> Number (treated as text) <code>int</code> or <code>float</code> <code>def my_func(...) -&gt; int:</code> or <code>def my_func(...) -&gt; float:</code> Image <code>PIL.Image.Image</code> <code>def my_func(...) -&gt; PIL.Image.Image:</code> Matplotlib figure <code>plt.Figure</code> <code>def my_func(...) -&gt; plt.Figure:</code> Plotly graph Built-in component <code>Graph</code> <code>def my_func(...) -&gt; Graph:</code> Pandas Dataframe <code>pd.DataFrame</code> or built-in component <code>Table</code>. Using <code>Table</code> lets you set the pagination page size using <code>Table(page_size=20)</code> <code>def my_func(...) -&gt; pd.DataFrame:</code> or <code>def my_func(...) -&gt; Table:</code> or <code>def my_func(...) -&gt; Table(page_size=20):</code> Conversation (chat) Built-in component <code>Chat</code>. Output must be formatted as a dictionary in the format <code>{\"query\": query, \"response\": response}</code> <code>def my_func(...) -&gt; Chat:</code>"},{"location":"User%20guide/patterns/#3-arranging-output-components","title":"3. Arranging output components","text":"<p>Fast Dash allows customizing the visual arrangement of your output components. The idea is using \u201cmosaics.\u201d Drawing inspiration from Matplotlib\u2019s <code>subplot_mosaic</code> method, Fast Dash lets you craft layouts using an ASCII-esque diagram or a string list.</p> <p>Each unique letter or string in this mosaic signifies a unique component. This approach is a game-changer, especially when you\u2019re aiming for non-uniform grid layouts.</p> <p>For example, imagine the output arrangement you want is something like in the following image:</p> <p></p> <p>In this case, you can define your mosaic to be \u201cABB \\n CDE\u201d. Fast Dash will set the app for five outputs and divide the space into six equally-sized boxes placed as a 2 x 3 grid. </p> <p>The first output gets the top-left box. The second output stretches across the next two boxes in the top row. And each of the remaining three outputs gets its own box in the row below.</p> <p>Refer to the examples below to understand this idea better.</p> Example 1: Two outputs <p>We have two outputs and we want them to appear one below the other.</p> <pre><code>mosaic = \"\"\"\nA\nB\n\"\"\"\n\n@fastdash(mosaic=mosaic)\ndef my_func(arg1: str) -&gt; (str, str):\n    return \"A\", \"B\"\n</code></pre> <p>Output:</p> <p></p> Example 2: Three outputs <p>We have three outputs. The first two should appear next to each other in the first row  and the third should appear below them taking up the entire second row.</p> <pre><code>mosaic = \"\"\"\nAB\nCC\n\"\"\"\n\n@fastdash(mosaic=mosaic)\ndef my_func(arg1: str) -&gt; (str, str, str):\n    return \"A\", \"B\", \"C\"\n</code></pre> <p>Output:</p> <p></p> Example 3: Four outputs <p>We have four outputs. The first two should appear one below the other in the first column,  and the remaining two should take up the entire second and third columns respectively.</p> <pre><code>mosaic = \"\"\"\nACD\nBCD\n\"\"\"\n\n@fastdash(mosaic=mosaic)\ndef my_func(arg1: str) -&gt; (str, str, str, str):\n    return \"A\", \"B\", \"C\", \"D\"\n</code></pre> <p>Output:</p> <p></p> Example 4: Five outputs <p>This example has five outputs. Here are the requirements:</p> <ul> <li>The 1st output must appear first.</li> <li>The 2nd output must be twice as wide as the first output.</li> <li>The 3rd, 4th and 5th outputs must be in the second row and have the same width.</li> </ul> <pre><code>mosaic = \"\"\"\nABB\nCDE\n\"\"\"\n\n@fastdash(mosaic=mosaic)\ndef my_func(arg1: str) -&gt; (str, str, str, str, str):\n    return \"A\", \"B\", \"C\", \"D\", \"E\"\n</code></pre> <p>Output: </p> <p></p> Example 5: Eight outputs <p>This is a slightly complicated example with 8 outputs, reminiscent of some BI dashboards. Here's what we want:</p> <ul> <li>The first 4 components appear one after the other horizontally (like overview KPIs in a dashboard).</li> <li>The 5th output appears directly below the first 3 components while the 6th appears directly below the 4th.</li> <li>The 7th appears directly below 5th and the 8th appears directly below the 6th.</li> <li>Let's add a complication intentionally: Components 5 through 8 should be twice as tall (vertically) as the first 4 components.</li> </ul> <p>No problem! it's easy to have this layout with Fast Dash just by writing the appropriate mosaic string, without touching the main Python code.</p> <pre><code># Notice that the second and third component rows have been repeated \n# to make them appear twice as high as the first component row\nmosaic = \"\"\"\nABCD\nEEEF\nEEEF\nGGGH\nGGGH\n\"\"\"\n\n@fastdash(mosaic=mosaic)\ndef my_func(arg1: str) -&gt; (str, str, str, str, str, str, str, str):\n    return \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"\n</code></pre> <p>Output: </p> <p></p>"},{"location":"User%20guide/patterns/#4-selecting-other-configurations","title":"4. Selecting other configurations","text":"<p>Finally, customize your app by controlling various options like the theme of the app, social media branding links, subheaders, deployment mode and so on.</p> <p>In the next section, we'll see what Fast Components are, what separates them from other Dash components, and how we can easily modify Dash components to make them compatible with Fast Dash.</p>"}]}